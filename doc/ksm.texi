\input texinfo
@setfilename ksm.info
@settitle KSM-Scheme Reference Manual

@ifinfo
This file documents simple info document.

Copyright 2001 Hangil Chang

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries a copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled ``Copying'' and ``GNU General Public License'' are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.

@end ifinfo

@titlepage
@center @titlefont{KSM-Scheme Reference Manual}
@sp 3
@center By Hangil Chang
@sp 2
@center March 3, 2001
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2001 Hangil Chang

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled ``Copying'' and ``GNU General Public License'' are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.

@end titlepage

@c ***************** MACRO ******************

@macro source {filename}
source: \filename\ @*
@end macro

@macro use {package}
use: \package\ @*
@end macro

@dircategory Programming
@direntry
* KSM-Scheme: (ksm). A Scheme Interperter.
@end direntry

@c ******************* Top **********************
@node Top, Invoking KSM-Scheme, (dir), (dir)
@top KSM-Scheme

KSM-Scheme is a Scheme interpreter that interfaces easily with C
variables and functions.

@menu
* Invoking KSM-Scheme::
* Scheme Programs::
* Identifiers::
* Literals::
* Lists::
* Other Notations::
* Whitespace and Comments::
* Standard Package::
* Base Package::
* C Package::
* Regex Package::
* Thread Package::
* C-like Syntax::
* Copying::
* GNU General Public License::
* Concept Index::
* Function Index::
@end menu

@c ******************* Invoking KSM-Scheme ********************
@node Invoking KSM-Scheme, Scheme Programs, Top, Top
@chapter Invoking KSM-Scheme

KSM-Scheme is invoked from the command line as

@example
ksm [options] [file arg ...]
@end example

Acceptable options are

@multitable @columnfractions 0.3 0.7
@item -xl @var{file}
@tab load @var{file} before starting the interpreter

@item -xc @var{encoding}
@tab set the default encoding to @var{encoding}

@item -xh 
@tab display the help information
@end multitable

If @var{encoding} is specified, input files (including standard input)
are assumed to be encoding by @var{encoding} and they are automatically
converted to UTF-8 encoding while reading the file. Output files
(including standard output and standard error) are automatically
converted to @var{encoding} from UTF-8 that is the internal encoding in
KSM-Scheme.

For example, to use KSM-Scheme under the circumstances in which
@code{kterm} with default encoding of EUC-JP is used, following
invocation will provide the desirable interaction.

@example
ksm -xc EUC-JP
@end example

If @var{file} is specified, it should be the name of a Scheme source
file. The KSM-Scheme interpreter loads the file and then terminates. If
@var{file} is omitted, KSM-Scheme enters an interactive mode and accepts
Scheme source from standard input. 

If @var{args} are specified, it is passed the @var{file} program as
command line arguments. They can be accessed by @code{cmdline-args} from
the program.

@example
$ cat src.scm
(display (cmdline-args))
(newline)
$ ksm src.scm a b c
(src.scm a b c)
@end example

When @code{ksm} is invoked, it initializes the internal state, loads the
initialization file that is located in the KSM home directory (e.g.,
@code{/usr/local/ksm/ksm-0.3.0}, loads the pre-load file that is
specified by @code{-xl} option (if present), and loads the source file
(if specified).

@c ******************* Scheme Programs *********************
@node Scheme Programs, Identifiers, Invoking KSM-Scheme, Top
@chapter Scheme Programs

A Scheme program consists of a sequence of expressions. For example,
following Scheme program displays "Hello, world!" in the standard output
and ends the line.

@example
(display "Hello, world!")
(newline)
@end example

Two Scheme expressions above are analogous to the following C
statements.

@example
printf("Hello, world!");
printf("\n");
@end example

Scheme expressions are composed from identifiers, literals, lists, and
vectors.

@c **************** Identifiers ******************
@node Identifiers, Literals, Scheme Programs, Top
@chapter Identifiers

An identifier is a sequence of characters such as @code{value} and
@code{sum}. In KSM-Scheme, a character represents a Unicode code and an
identifier can be any combination of Unicode characters if following
conditions are satisfied. 1) It does not begin with @code{(}, @code{)},
@code{'}, @code{`}, @code{,}, @code{"}, @code{[}, @code{]}, @code{|},
@code{#}, @code{;}, or @code{:}. 2) It does not include whitespaces,
@code{(}, @code{)}, and @code{;}. Finally, 3) it cannot be interpreted
as a number.

@noindent Here are some examples of identifiers:

@example
lambda
list->vector 
+
<=?
the-word-recusrion-has-many-meanings
q
soup
V17a
a34kTMNs
@end example

@noindent And these are not identifiers:
@example
(123)    ;; starting with `('
"abc"    ;; starting with `"'
123      ;; it's a number
+3.21    ;; it's a number
-.123    ;; it's a number
@end example

KSM-Scheme is case-sensitive in contrast to the Scheme
Standard. Therefore, following identifiers represent distinct objects.

@example
Identifier
identifier
IDENTIFIER
@end example

This decision was made to make KSM-Scheme easily interface with C
functions.

@c ***************** Literals *****************
@node Literals, Lists, Identifiers, Top
@chapter Literals

In KSM-Scheme, literals represent characters, strings, numbers,
booleans, and other objects.

@menu
* Characters::
* Strings::
* Numbers::
@end menu

@c *************** Characters ********************
@node Characters, Strings, Literals, Literals
@section Characters

Characters are written using the notation @code{#\<character>} or
@code{#\<character name>}. For example,

@example
#\a             ; lower case letter
#\A             ; upper case letter
#\(             ; left parenthesis
#\              ; the space character
#\space         ; the preferred way to write a space
#\newline       ; the newline character
@end example

Case is significant in @code{#\<character>}, but not in
@code{#\<character name>}. If @code{<characer>} in @code{#\<character>}
is alphabetic, then the character following @code{<character>} must be a
delimiter character such as a space or parenthesis. This rule resolves
the ambiguous case where, for example, the sequence of characters
@code{#\space} could be taken to be either a representation of the space
character or a representation of the character @code{#\s} followed by a
representation of the identifier @code{pace}.

In KSM-Scheme, characters can also be written in the form of
@code{#\U@{XXXX@}}, which represents a character with Unicode code value
of @code{XXXX} (hexadecimal).

@example
#\U@{63@}       ; small letter a
#\U@{D@}        ; carriage return
#\U@{3042@}     ; hiragana letter a
#\U@{feff@}     ; zero width no-break space
@end example

@c ***************** Strings *****************
@node Strings, Numbers, Characters, Literals
@section Strings

Strings are sequences of characters. Strings are written as sequences of
characters enclosed within doublequotes ("). A doublequote can be
written inside a string only by escaping it with a backslash (\), as in

@example
"The word \"recursion\" has many meanings."
@end example

A backslash can be written inside a string only by escaping it with
another backslash. In KSM-Scheme, additional escaping sequences are
present, as follows.

@example
"\""      ==> "  (a string composed of a doublequote character)
"\\"      ==> \
"\n"      ==> newline
"\r"      ==> carriage return
"\t"      ==> tab
"\U@{XXXX@} ==> character corresponding to Unicode 
              code value XXXX (hexadecimal)
@end example

When a backslash is followed by a character that is not listed above,
backslash looses its special meaning and represents a backslash
character by itself.

@example
"\b"  ==> a string composed of two characters ('\' and 'b').
@end example

In KSM-Scheme, a string constant may include a newline character. In
other words, a string constant may continue from one line to the next.

@example
"line 1
line 2"    ==> a string including a newline 
@end example

The @emph{length} of a string is the number of characters that it
contains. This number is an exact, non-negative integer that is fixed
when the string is created. The @emph{valid indexes} of a string are the
exact non-negative integers less than the length of the string. The
first character of a string has index 0, the second has index 1, and so
on.

In KSM-Scheme, a string is encoded by UTF-8 (Unicode Transformation
Format, 8-bit form". This means that if all the characters in a string
are ASCII characters (that is, #\U@{00@} through #\U@{7F@}) the
length of the string is equal with the byte size of the
string. However, if it includes a character out of this range, the byte
size of the string is larger than its length.

In phrases such as "the characters of @emph{string} beginning with index
@emph{start} and ending with index @emph{end}," it is understood that
the index @emph{start} is inclusive and the index @emph{end} is
exclusive. Thus if @emph{start} and @emph{end} are the same index, a
null substring is referred to, and if @emph{start} is zero and
@emph{end} is the length of @emph{string}, then the entire string is
referred to.

@c ****************** Numbers ********************
@node Numbers,  , Strings, Literals
@section Numbers

A number may be written in binary, octal, decimal, or hexadecimal by the
use of a radix prefix. The radix prefixes are @code{#b} (binary),
@code{#o} (octal), @code{#d} (decimal), and @code{#x}
(hexadecimal). With no radix prefix, a number is assumed to be expressed
in decimal.

@example
#b1011    ==> 11   (decimal)
#o1011    ==> 521  (decimal)
#d1011    ==> 1011 (decimal)
#x1011    ==> 4113 (decimal)
@end example

A numerical constant may be specified to be either exact (that is,
integer) or inexact (that is, floating point number) by a prefix. The
prefixes are @code{#e} for exact, and @code{#i} for inexact. An
exactness prefix may appear before or after any radix prefix that is
used. If the written represen representation of a number has no
exactness prefix, the constant may be either inexact or exact. It is
inexact if it contains a decimal point or an exponent.

@example
12345     ==> integer (exact)
123.45    ==> floating point number (inexact)
123.4e5   ==> floating point number
#eb1011   ==> 11 (decimal, exact)
#ib1011   ==> 11.0 (decimal, inexact)
#bi1011   ==> 11.0 (same as above)
@end example

A rational number is written in the form <integer>/<positive
integer>. Between <integer>, '/', and <positive integer>, no space is
allowed. Radix prefixes are not allowed to write <integer>. Rational
numbers are supported only if GMP library is available ("libgmp.so" and
"gmp.h" exist).

@example
1/2       ==> one half (rational)
2/4       ==> 1/2 (same as above)
@end example

A complex number is written in the form <number>+<number>i. That is, a
number followed immediately by '+', another number and 'i'. First number
specifies the real part and the second specifies the imaginary
part. Radix prefixes are not allowed to write <number>. 

@example
1+2i
0+-2i       ==> real part is 0; imaginary part is -2
1.2+3.4i
-2.3+4.5i   ==> real part is -2.3; imaginary part is 4.5
@end example

@c ******************** Lists *********************
@node Lists, Other Notations, Literals, Top
@chapter Lists

List is represented by a sequence of elements within parentheses. Each
element is separated by space.

@example
(1 2 3 4 5)
(apple banana orange)
(#\H #\e #\l #\l #\o)
@end example

Evaluation of a list is conducted in two different ways depending on the
first element in the list. When evaluation of the first element results
in a function, remaining elements are evaluated and the function is
called with those evaluated values as arguments. For example, the
identifier @code{+} evaluates to a function that returns the sum of its
arguments. 

@example
(+ 1 2)             ==> 3
(+ 1 2 3 4)         ==> 10
(+ (+ 1 2) (+ 3 4)  ==> 10
@end example

In another form of evaluation, the first element represents an
invocation of pre-defined special form. How the remaining elements are
evaluated depends on the individual special forms. For example,
@code{define} represents a special form that defines a variable. The first
argument indicates the name of the variable, and the evaluation of the
second argument specifies the value of the variable.

@example
(define a (+ 10 20))
@end example

Evaluation of the above form returns an unspecified value. As a side
effect, it defines a variable named @code{a} whose value is 30.

In Scheme, lists are constructed from pairs. A pair is a record
structure with two fields called the @emph{car} and @emph{cdr} fields
(for historical reasons). A two-element list is a pair whose car is the
first element and whose cdr is a pair whose car is the second element
and whose cdr is the empty list. The empty list is a special object of
its own and is represented by @code{()}.

The most general notation for Scheme pairs is the ``dotted'' notation
@code{(c1 . c2)} where @code{c1} is the value of the car field and
@code{c2} is the value of the cdr field. For example @code{(4 . 5)} is a
pair whose car is @code{4} and whose cdr is @code{5}. For example,
@example
(a b c d e)
@end example
and
@example
(a . (b . (c . (d . (e . ())))))
@end example
are equivalent notations for a list of symbols.

A chain of pairs not ending in the empty list is called an
@emph{improper list}. The list and dotted notations can be combined to
represent improper lists:
@example
(a b c . d)
@end example
is equivalent to
@example
(a . (b . (c . d)))
@end example

@c ***************** Other Notations **************
@node Other Notations, Whitespace and Comments, Lists, Top
@chapter Other Notations
@cindex other notations

@multitable @columnfractions .3 .7
@item @code{'obj}
@tab equivalent to @code{(quote obj)}

@item @code{`obj}
@tab equivalent to @code{(quasi-quote obj)}

@item @code{,obj}
@tab equivalent to @code{(unquote obj)}

@item @code{,@@obj}
@tab equivalent to @code{(unquote-splicing obj)}

@item @code{#t}
@tab represents @emph{true} in Scheme

@item @code{#f}
@tab represents @emph{false} in Scheme

@item @code{#(obj ...)}
@tab represents a vector whose elements are obj ...

@item @code{[ ]}
@tab Left and right square brackets have no special meaning in
KSM-Scheme. They can constitue identifiers as usual characters.

@item @code{@{ @}}
@tab Left and right curly braces have no special meaning in
KSM-Scheme. They can constitue identifiers as usual characters.

@item @code{|}
@tab Vertical bar has no special meaning in
KSM-Scheme. It can constitue identifiers as usual character.

@item @code{#<eof>}
@tab Represents the end of file object.

@item @code{#<unspecified>}
@tab Represents an unspecified value.

@end multitable

The standard boolean objects for true and false are written as @code{#t}
and @code{#f}. What really matters, though, are the objects that the
Scheme conditional expressions (@code{if}, @code{cond}, @code{and}, ...)
treat as true or false. The phrase ``a true value'' (or sometimes just
``true'') means any object other than the object represented by
@code{#f}. The phrase ``a false value'' (or ``false'') means the object
represented by @code{#f}. In this sense, the empty list and the symbol
@code{nil} are ``true values'' in Scheme.

@c ************* Whitespace and Comments ****************
@node Whitespace and Comments, Standard Package, Other Notations, Top
@chapter Whitespace and Comments
@cindex whitespace
@cindex comment

In KSM-Scheme, whitespace characters are spaces, tabs, and
newlines. Whitespace is used for improved readability and is necessary
to separate tokens from each other but is otherwise insignificant.

A semicolon (@code{;}) indicates the start of a comment. The comment
continues to the end of the line on which the semicolon
appears. Comments are invisible to Scheme, but the end of the line is
visible as whitespace. This prevents a comment from appearing in the
middle of an identifier or number.

@lisp
;;; The FACT procedure computes the factorial
;;; of a non-negative integer.
(define fact
  (lambda (n)
    (if (= n 0)
        1          ;Base case: return 1
        (* n (fact (- n 1))))))
@end lisp

Two characters @code{#!} (character @code{#} followed by @code{!}) also
starts a comment. The comment continues to the end of the line on which
@code{#!} appears. This enables a Scheme program executed as an
interpreter file, like this:

@lisp
#!/usr/local/bin/ksm -f
(display "Hello, world!")
(newline)
@end lisp

@c ****************** Standard Package ****************
@node Standard Package, Base Package, Whitespace and Comments, Top
@chapter Standard Package

Standard package includes special forms and built-in functions listed in
Scheme Standard.

@menu
* Special Forms::
* Quasiquotation::
* Macro::
* Delayed Evaluation::
* Equivalence::
* Numerical Operations::
* Numerical I/O::
* Booleans::
* Pairs and Lists::
* Symbol::
* Character: Std-Character.
* String: Std-String.
* Vector: Std-Vector.
* Control Features: Std-Control-Features.
* Eval: Std-Eval.
* Port: Std-Port.
* Input: Std-Input.
* Output: Std-Output.
* System Interface: Std-System-Interface.
@end menu

@c ****************** Special Forms ********************
@node Special Forms, Quasiquotation, Standard Package, Standard Package
@section Special Forms

@defspec quote @var{datum}
@defspecx '@var{datum}
(@code{quote} @var{datum}) evaluates to @var{datum}. @var{Datum} may be
any external representation of a Scheme object. This notation is used to
include literal constants in Scheme code.

@example
(quote a)         ==> a
(quote #(a b c))  ==> #(a b c)
(quote (+ 1 2))   ==> (+ 1 2)
@end example

(@code{quote} @var{datum}) may be abbreviated as
@code{'}@var{datum}. The two notations are equivalent in all respects.

@example
'a              ==> a
'#(a b c)       ==> #(a b c)
'()             ==> ()
'(+ 1 2)        ==> (+ 1 2)
'(quote a)      ==> (quote a)
''a             ==> (quote a)
@end example
@end defspec

@defspec lambda @var{formals} @var{body}
@var{Formals} should be a formal arguments list as described below, and
@var{body} should be a sequence of one or more expressions.

A @code{lambda} expression evaluates to a procedure. The environment in
effect when the @code{lambda} expression was evaluated is remembered as
part of the procedure. When the procedure is later called with some
actual arguments, the environment in which the @code{lambda} expression
was evaluated will be extended by binding the variables in the formal
argument list to fresh locations, the corresponding actual argument
values will be stored in those locations, and the expression in the body
of the @code{lambda} expression will be evaluated sequentially in the
extended environment. The result of the last expression in the body will
be returned as the result of the procedure call.

@example
(lambda (x) (+ x x))      ==> a procedure
((lambda (x) (+ x x)) 4)  ==> 8

(define reverse-subtract
  (lambda (x y) (- y x)))
(reverse-subtract 7 10)   ==> 3

(define add4
  (let ((x 4))
    (lambda (y) (+ x y))))
(add4 6)                  ==> 10

@end example

@var{Formals} should have one of the following forms:
@itemize @bullet
@item
(@var{variable1} ...): The procedure takes a fixed number of arguments;
when the procedure is called, the arguments will be stored in the
bindings of the corresponding variables. 

@item
@var{variable}: The procedure takes any number of arguments; when the
procedure is called, the sequence of actual arguments is converted into
a newly allocated list, and the list is stored in the binding of the
@var{variable}.

@example
((lambda x x) 3 4 5 6)    ==> (3 4 5 6)
@end example

@item
(@var{variable-1} ... @var{variable-n} . @var{variable-n+1}): If a space
delimited period precedes the last variable, then the procedure takes
@emph{n} or more arguments, where @emph{n} is the number of formal
arguments before the period (there must be at least one). The value
stored in the binding of the last variable will be a newly allocated
list of the actual arguments left over after all the other actual
arguments have been matched up against the other formal arguments.

@example
((lambda (x y . z) z) 3 4 5 6)  ==> (5 6)
@end example

@item
(@var{variable} ... [&optional @var{variable} (@var{variable}
init-value) (@var{variable}) ...] [&rest @var{variable}] [&key
@var{variable} (@var{variable} init-value) ...]): Leading
@var{variable}'s are required parameters as above. @var{Variable}'s
following ``&optional'' is optional parameters. In its first form,
``@var{variable}'', bound value is set to '() if no argument is
supplied. In its second form, ``(@var{variable} init-value'', init-value
is evaluated at run-time and bound with @var{variable} if no argument is
supplied. In its third form, ``(@var{variable})'', list of remaining
arguments excluding keyword arguments (see below) is bound to
@var{variable}. @var{Variable} that follows ``&rest'' is bound to the
list of remaining arguments. @var{Variable}'s following ``&key'' are
keyword arguments. In its first form, ``@var{variable}'', @var{variable}
is bound to '() if keyword argument is not supplied. In its second form,
``@var{variable} init-value'', init-value is evaluated at run-time and
bound to @var{variable} if keyword argument is not supplied. When
calling lambda functions with keyword arguments, keyword argument is
specified by an identifier prefixed by ':' followed by its value.

@example

(define (f a b &optional c) (list a b c))
(f 1 2 3) ==> (1 2 3)
(f 1 2) ==> (1 2 '())

(define (f a b &optional (c 10)) (list a b c))
(f 1 2 3) ==> (1 2 3)
(f 1 2) ==> (1 2 10)

(define (f a b &rest rest) (list a b rest))
(f 1 2 3 4 5) ==> (1 2 (3 4 5))

(define (f a b &key c) (list a b c))
(f 1 2 :c 12) ==> (1 2 12)
(f 1 2) ==> (1 2 '())

(define (f a b &key (c 100) (d 200)) (list a b c d))
(f 1 2 :d 4 :c 3) ==> (1 2 3 4)
(f 1 2) ==> (1 2 100 200)

(define (f a b &optional (args) &key c) args)
(f 1 2 3 4 5 :c 100) ==> (3 4 5)

(define (f a b &optional (args) &rest rest &key c) args)
(f 1 2 3 4 5 :c 100) ==> (3 4 5)

(define (f a b &optional (args) &rest rest &key c) rest)
(f 1 2 3 4 5 :c 100) ==> (:c 100)

@end example

@end itemize

@end defspec   

@defspec define @var{variable} @var{expression}
@defspecx define (@var{variable} @var{formals}) @var{body}
@defspecx define (@var{variable} . @var{formal}) @var{body}
In the second form, @var{formals} should be either a sequence of zero or
more variables, or a sequence of one or more variables followed by a
space-delimited period and another variable. This form is equivalent to
@example
(define @var{variable}
  (lambda (@var{formals}) body))
@end example

In the third form, @var{formal} should be a single variable. This form
is equivalent to
@example
(define @var{variable}
  (lambda @var{formal} @var{body}))
@end example

At the top level of a program, a definition
@example
(define @var{variable} @var{expression})
@end example
has essentially the same effect as the assignment expression
@example
(set! @var{variable} @var{expression})
@end example
if @var{variable} is bound. If @var{variable} is not bound, however,
then the definition will bind @var{variable} to a new location before
performing the assignment, whereas it would be an error to perform
@code{set!} on an unbound variable.

@example
(define add3
  (lambda (x) (+ x 3)))
(add3 3)                 ==> 6
(define first car)
(first '(1 2))           ==> 1
@end example

Definitions may occur at the beginning of a @var{body} (that is, the
body of a @code{lambda}, @code{let}, @code{let*}, @code{letrec},
@code{let-syntax}, or @code{letrec-syntax} expression). Such definitions
are known as @emph{internal definitions} as opposed to the top level
definitions described above. The variable defined by an internal
definition is local to the @var{body}. That is, @var{variable} is bound
rather than assigned, and the scope of the binding is the entire
@var{body}. For example,

@example
(let ((x 5))
  (define foo (lambda (y) (bar x y)))
  (define bar (lambda (a b) (+ (* a b) a)))
  (foo (+ x 3)))         ==> 45
@end example

A @var{body} containing internal definitions can always be converted
into a completely equivalent @code{letrec} expression. For example, the
@code{let} expression in the above example is equivalent to 

@example
(let ((x 5))
  (letrec ((foo (lambda (y) (bar x y)))
           (bar (lambda (a b) (+ (* a b) a))))
    (foo (+ x 3))))
@end example

Just as for the equivalent @code{letrec} expression, it must be possible
to evaluate each @var{expression} of every internal definition in a
@var{body} without assigning or referring to the value of any
@var{variable} being defined.
@end defspec

@defspec if @var{test} @var{consequent} @var{alternate}
@defspecx if @var{test} @var{consequent}

An @code{if} expression is evaluated as follows: first, @var{test} is
evaluated. If it yields a true value, then @var{consequent} is evaluated
and its value is returned. Otherwise @var{alternate} is evaluated and
its value is returned. If @var{test} yields a false value and no
@var{alternate} is specified, then the result of the expression is
unspecified. 

@example
(if (> 3 2) 'yes 'no)          ==> yes
(if (> 2 3) 'yes 'no)          ==> no
(if (> 3 2) (- 3 2) (+ 3 2))   ==> 1
@end example

@end defspec

@defspec set! @var{variable} @var{expression}
@var{Expression} is evaluated, and the resulting value is stored in the
location to which @var{variable} is bound. @var{Variable} must be bound
either in some region enclosing the @code{set!} expression or at top
level. The result of the @code{set!} expression is unspecified.
@example
(define x 2)
(+ x 1)           ==> 3
(set! x 4)
(+ x 1)           ==> 5
@end example
@end defspec

@defspec set-value! @var{variable} @var{expression}
Same with @code{set!}, but returns the value of @var{expression}

@example
(define x 1)
(set! x 10)        ==> #<unspecified>
(set-value! x 20)  ==> 20       
@end example
@end defspec

@defspec cond @var{clause1} @var{claus2}
Each @var{clause} should be of the form
@example
(@var{test} @var{expression} ...)
@end example
where @var{test} is any expression. Alternatively, a @var{clause} may be
of the form
@example
(@var{test} => @var{expression})
@end example
The last @var{clause} may be an ``else clause,'' which has the form
@example
(else @var{expression1} @var{expression2} ...)
@end example

A @code{cond} expression is evaluated by evaluating the @var{test}
expression of successive @var{clause}'s in order until one of them
evaluates to a true value. When a @var{test} evaluates to a true value,
then the remaining @var{expression}'s in its @var{clause} are evaluated
in order, and the result of the last @var{expression} in the
@var{clause} is returned as the result of the entire @code{cond}
expression. If the selected @var{clause} contains only the @var{test}
and no @var{expression}'s, then the value of the @var{test} is returned
as the result. If the selected @var{clause} uses the @code{=>} alternate
form, then the @var{expression} is evaluated. Its value must be a
procedure that accepts one argument; this procedure is then called with
the value of the @var{test} as the only argument and the value returned
by this procedure is returned by the @code{cond} expression. If all
@var{test}'s evaluate to false values, and there is no else clause, then
the result of evaluation of the @code{cond} expression is unspecified;
if there is an else clause, then its @var{expression}'s are evaluated,
and the value of the last one is returned.
@example
(cond ((> 3 2) 'greater)
      ((< 3 2) 'less))      ==> greater
(cond ((> 3 3) 'greater)
      ((< 3 3) 'less)
      (else 'equal)         ==> equal
(cond ((assv 'b '((a 1) (b 2))) => cadr)
      (else #f))            ==> 2
@end example
@end defspec

@defspec case @var{key} @var{clause1} @var{clause2} ...
@var{Key} may be any expression. Each @var{clause} should have the form
@example
((@var{datum1} ...) @var{expression1} @var{expression2} ...)
@end example
where each @var{datum} is an identifier or a literal. All the
@var{datum}'s must be distinct. The last @var{clause} may be an ``else
clause,'' which has the form
@example
(else @var{expression1} @var{expression2} ...)
@end example

A @code{case} expression is evaluated as follows. @var{Key} is evaluated
and its result is compared against each @var{datum}. If the result of
evaluating @var{key} is equivalent (in the sense of @var{eqv?}) to a
@var{datum}, then the expressions in the corresponding @var{clause} are
evaluated from left to right and the result of the last expression in
the clause is returned as the result of the @code{case} expression. If
the result of evaluating @var{key} is different from every @var{datum},
then if there is an else clause its expressions are evaluated and the
result of the last is the result of the @code{case} expression;
otherwise the result of the @code{case} expression is unspecified. 

@example
(case (* 2 3)
  ((2 3 5 7) 'prime)
  ((1 4 6 8 9) 'composite))   ==> composite
(case (car '(c d))
  ((a) 'a)
  ((b) 'b))                   ==> #<unspecified>
(case (car '(c d))
  ((a e i o u) 'vowel)
  ((w y) 'semivowel)
  (else 'consonant))          ==> consonant
@end example
@end defspec

@defspec and @var{test1} ...
The @var{test} expressions are evaluated from left to right, and the
value of the first expression that evaluates to a false value is
returned. Any remaining expressions are not evaluated. If all the
expressions evaluate to true values, the value of the last expression is
returned. If there are no expression then @code{#t} is returned.

@example
(and (= 2 2) (> 2 1))     ==> #t
(and (= 2 2) (< 2 1))     ==> #f
(and 1 2 'c '(f g))       ==> (f g)
(and)                     ==> #t
@end example
@end defspec

@defspec or @var{test1} ...
The @var{test} expressions are evaluated from left to right, and the
value of the first expression that evaluates to a true value is
returned. Any remaining expressions are not evaluated. If all the
expressions evaluate to false values, the value of the last expression
is returned. If there are no expression then @code{#f} is returned.

@example
(or (= 2 2) (> 2 1))      ==> #t
(or (= 2 2) (< 2 1))      ==> #t
(or #f #f #f)             ==> #f
(or (memq 'b '(a b c))
    (/ 3 0))              ==> (b c)
(or)                      ==> #f
@end example

@end defspec

@defspec let @var{bindings} @var{body}
@var{Bindings} should have the form
@example
((@var{variable1} @var{init1}) ...)
@end example
where each @var{init} is an expression, and @var{body} should be a
sequence of one or more expressions. It is an error for a @var{variable}
to appear more than once in the list of variables being bound.

The @var{init}'s are evaluated in the current environment (in some
unspecified order), the @var{variable}'s are bound to fresh locations
holding the results, the @var{body} is evaluted in the extended
environment, and the value of the last expression of @var{body} is
returned. Scope of each @var{variable} is restricted to @var{body}.

@example
(let ((x 2) (y 3))
  (* x y))                ==> 6
(let ((x 2) (y 3))
  (let ((x 7)
        (z (+ x y)))
    (* z x)))             ==> 35
@end example
@end defspec

@defspec let @var{variable} @var{bidings} @var{body}
``Named @code{let}'' is a variant on the syntax of @code{let} which
provides a more general looping construct than @code{do} and may also be
used to express recursions. It has the same syntax and semantics as
ordinary @code{let} except that @var{variable} is bound within
@var{body} to a procedure whose formal arguments are the bound variables
and whose body is @var{body}. Thus the execution of @var{body} may be
repeated by invoking the procedure named by @var{variable}.

@example
(let loop ((numbers '(3 -2 1 6 -5))
           (nonneg '())
           (neg '()))
  (cond ((null? numbers) (list nonneg neg))
        ((>= (car numbers) 0)
         (loop (cdr numbers)
               (cons (car numbers) nonneg)
               neg))
        ((< (car numbers) 0)
         (loop (cdr numbers)
               nonneg
               (cons (car numbers) neg)))))
        ==> ((6 1 3) (-5 -2))
@end example
@end defspec

@defspec let* @var{bindings} @var{body}
@var{Bindings} should have the form
@example
((@var{variable1} @var{init1}) ...)
@end example
where each @var{init} is an expression, and @var{body} should be a
sequence of one or more expressions. 

@code{let*} is similar to @code{let}, but the bindings are performed
sequentially from left to right, and the region of a binding indicated
by (@var{variable} @var{init}) is that part of the @code{let*}
expression to the right of the binding. Thus the second binding is done
in an environment in which the first binding is visible, and so on.

@example
(let ((x 2) (y 3))
  (let* ((x 7)
         (z (+ x y)))
    (* z x)))             ==> 70
@end example
@end defspec

@defspec letrec @var{bindings} @var{body}
@var{Bindings} should have the form
@example
((@var{variable1} @var{init1}) ...)
@end example
and @var{body} should be a sequence of one or more expressions. It is an
error for a @var{variable} to appear more than once in the list of
variables being bound.

The @var{variable}'s are bound to fresh locations holding undefined
values, the @var{init}'s are evaluated in the resulting environment (in
some unspecified order), each @var{variable} is assigned to the result
of the corresponding @var{init}, the @var{body} is evaluated in the
resulting environment, and the value of the last expression in
@var{body} is returned. Scope of each binding of a @var{variable} is
the entire @code{letrec} expression, making it possible to define
mutually excursive procedures.

@example
(letrec ((even?
          (lambda (n)
           (if (zero? n)
               #t
               (odd? (- n 1)))))
         (odd?
          (lambda (n)
           (if (zero? n)
               #f
               (even? (- n 1))))))
 (even? 88))
               ==> #t
@end example

One restriction on @code{letrec} is very important: it must be possible
to evaluate each @var{init} without assigning or referring to the value
of any @var{variable}. If this restriction is violated, then it is an
error. The restriction is necessary because Scheme passes arguments by
value rather than by name. In the most common uses of @code{letrec}, all
the @var{init}'s are @code{lambda} expressions and the retriction is
satisfied automatically.
@end defspec

@defspec begin @var{expression1} @var{expression2} ...
The @var{expression}'s are evaluated sequentially from left to right,
and the value of the last @var{expression} is returned. This expression
type is used to sequence side effects such as input and output.

@example
(define x 0)

(begin (set! x 5) (+ x 1)) ==> 6

(begin (display "4 plus 1 equals ")
       (display (+ 4 1)))  ==> prints "4 plus 1 equals 5", and
                               returns #<unspecified>
@end example
@end defspec

@defspec do @var{bindings} @var{test-clause} @var{body}
@var{Bindings} should have the form
@example
((@var{variable1} @var{init1} @var{step1}) ...),
@end example
the @var{test-clause} should have the form
@example
(@var{test} @var{expression} ...),
@end example
and the @var{body} should be a sequence of one or more expressions.

@code{do} is an iteration construct. It specifies a set of variables to
be bound, how they are to be initialized at the start, and how they are
to be updated on each iteration. When a termination condition is met,
the loop exits after evaluating the @var{expression}'s.

@code{do} expressions are evaluated as follows: The @var{init}
expressions are evaluated (in sompe unspecified order), the
@var{variable}'s are bound to fresh locations, the results of the
@var{init} expressions are stored in the bindings of the
@var{variable}'s, and then the iteration phase begins.

Each iteration begins by evaluating @var{test}; if the result is false,
then the expressions in the @var{body} are evaluated in order for
effect, the @var{step} expressions are evaluated in some unspecified
order, the @var{variable}'s are bound to fresh locations, the results of
the @var{step}'s are stored in the bindings of the @var{variable}'s, and
the next iteration begins.

If @var{test} evaluates to a true value, then the @var{expression}'s in
the @var{test-clause} evalutated from left to right and the value of the
last @var{expression} is returned. If no @var{expression}'s are present,
then the value of the @code{do} expression is unspecified.

Scope of the binding of a @var{variable} is the entire @code{do}
expression except for the @var{init}'s. It is an error for a
@var{variable} to appear more than once in the list of @code{do}
variables.

A @var{step} may be omitted, in which case the effect is the same as if
(@var{variable} @var{init} @var{variable}) had been written instead of
(@var{variable} @var{init}).

@example
(do ((vec (make-vector 5))
     (i 0 (+ i 1)))
    ((= i 5) vec)
  (vector-set! vec i i))   ==> #(0 1 2 3 4)

(let ((x '(1 3 5 7 9)))
  (do ((x x (cdr x))
       (sum 0 (+ sum (car x))))
      ((null? x) sum)))    ==> 25
 
@end example
@end defspec

@defspec prog1 @var{expr1} @var{expr} ...
Evaluates @var{expr1}, @var{expr}, ..., sequentially, and returns the
value of @var{expr1}.

@example
$car number.txt
123
$ ksm
> (let ((port (open-input-file "number.txt")))
    (prog1 (read port)
      (close-input-port port)))
=> 123
@end example

@source{base/base.c}
@use{none}
@end defspec

@c ****************** Quasiquotation *****************
@node Quasiquotation, Macro, Special Forms, Standard Package
@section Quasiquotation

@defspec quasiquote @var{qq-template}
@defspecx `@var{qq-template}
``Backquote'' or ``quasiquote'' expressions are useful for constructing
a list or vector structure when mose but not all of the desired
structure is known in advance. If no commas appear within the
@var{qq-template}, the result of evaluating `@var{qq-template} is
equivalent to the result of evaluating '@var{qq-template}. If a comma
appears within the @var{qq-template}, however, the expression following
the comma is evaluated (``unquoted'') and its result is inserted into
the structure instead of the comma and the expression. If a comma
appears followed immediately by an at-sign (@@), then the following
expression must evaluate to a list; the opening and closing parentheses
of the list are then ``stripped away'' and the elements of the list are
inserted in the place of the comma at-sign expression sequence. A comma
at-sign should only appear within a list or vector @var{qq-template}.

@example
`(list ,(+ 1 2) 4)      ==> (list 3 4)
(let ((name 'a))
  `(list ,name ',name)) ==> (list a (quote a))
`(a ,(+ 1 2) ,@@(map abs '(4 -5 6)) b)
                        ==> (a 3 4 5 6 b)
`((foo ,(- 10 3)) ,@@(cdr '(c)) . ,(car '(cons)))
                        ==> ((foo 7) . cons)
`#(10 5 ,(sqrt 4) ,@@(map sqrt '(16 9)) 8)
                        ==> #(10 5 2 4 3 8)
@end example

Quasiquote forms may be nested. Substitutions are made only for unquoted
components appearing at the same nesting level as the outermost
backquote. The nesting level increases by one inside each successive
quasiquotation, and decreases by one inside each unquotation.

@example
`(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f)
            ==> (a `(b ,(+ 1 2) ,(foo 4 d) e) f)
(let ((name1 'x)
      (name2 'y))
  `(a `(b ,,name1 ,',name2 d) e))
            ==> (a `(b ,x ,'y d) e)
@end example

The two notations `@var{qq-template} and (@code{quasiquote}
@var{qq-template}) are identical in all respects. ,@var{expression} is
identical to (@code{unquote} @var{expression}), and ,@@@var{expression}
is identical to (unquote-splicing @var{expression}). 
@end defspec

@c ****************** Macro ********************
@node Macro, Delayed Evaluation, Quasiquotation, Standard Package
@section Macro

@defspec define-syntax @var{keyword} @var{transformer-spec}
Syntax definitions are valid only at the top level of a
program. @var{keyword} is an identifier, and the @var{transformer-spec}
should be an instance of @code{syntax-rules}. The top-level syntactic
environment is extended by binding the @var{keyword} to the specified
transformer.
@end defspec

@defspec syntax-rules @var{literals} @var{syntax-rule} ...
@var{literals} is a list of identifiers and each @var{syntax-rule}
should be of the form
@example
(@var{pattern} @var{template})
@end example
The @var{pattern} in a @var{syntax-rule} is a list @var{pattern} that
begins with the keyword for the macro.

A @var{pattern} is either an identifier, a constant, or one of the
following.
@example
(@var{pattern} ...)
(@var{pattern} @var{pattern} ... . @var{pattern})
(@var{pattern} ... @var{pattern} @var{ellipsis})
#(@var{pattern} ...)
#(@var{pattern} ... @var{pattern} @var{ellipsis})
@end example
and a template is either an identifier, a constant, or one of the
following
@example
(@var{element} ...)
(@var{element} ... . @var{template})
#(@var{element} ....)
@end example
where an @var{element} is a @var{template} optionally followed by an
@var{ellipsis} and an @var{ellipsis} is the identifier ``...'' (which
cannot be used as an identifier in either a template or a pattern).

An instance of @code{syntax-rules} produces a new macro transformer by
specifying a sequence of hygienic rewrite rules. A use of a macro whose
keyword is associated with a transformer specified by
@code{syntax-rules} is matched against the patterns contained in the
@var{syntax-rule}'s, beginning with the leftmost @var{syntax-rule}. When
a match is found, the macro use is transcribed hygienically according to
the template.

An identifier that appears in the pattern of a @var{syntax-rule} is a
@emph{pattern variable}, unless it is the keyword the begins the
pattern, is listed in @var{literals}, or is the identifier
``...''. Pattern variables match arbitrary input elements and are used
to refer to elements of the input in the template. It is an error for
the same pattern variable to appear more than once in a @var{patter}.

Th keyword at the beginning of the pattern in a @var{syntax-rule} is not
involved in the matching and is not considered a pattern variable or
literal identifier.

Identifiers that appear in @var{literals} are interpreted as literal
identifiers to be matched against corresponding subforms of the input. A
subform in the input matches a literal identifier if the two identifiers
are equal.

A subpattern followed by ... can match zero or more elements of the
input. It is an error for ... to appear in @var{literals}. Within a
pattern the identifier ... must follow the last element of a nonempty
sequence of subpatterns.

More formally, an input form F matches a pattern P if and
only if:

@itemize @bullet
@item
P is a non-literal identifier; or

@item
P is a literal identifier and F is the equal identifier;
or

@item
P is a list (P1 ... Pn) and F is a list of n forms that match P1 through
Pn, respectively; or

@item
P is an improper list (P1 P2 ... Pn . Pn+1) and F is a list or improper
list of n or more forms that match P1 through Pn, respectively, and
whose n-th ``cdr'' matches Pn+1; or

@item
P is the form (P1 ... Pn Pn+1 @var{ellipsis}) where @var{ellipsis} is
the identifier ... and F is a proper list of at least n forms, the first
n of which match P1 through Pn, respectively, and each remaining element
of F matches Pn+1; or

@item
P is a vector of the form #(P1 ... Pn) and F is a vector of n forms that
match P1 through Pn; or

@item
P is of the form #(P1 ... Pn Pn+1 @var{ellipsis}) where @var{ellipsis}
is the identifier ... and F is a vector of n or more forms, the first n
of which match P1 through Pn, respectively, and each remaining element
of F matches Pn+1; or

@item
P is a datum and F is equal to P in the sense of the @code{equal?}
procedure.
 
@end itemize

It is an error to use a macro keyword, within the scope of its binding,
in an expression that does not match any of the patterns.

When a macro use is transcribed according to the template of the
matching @var{syntax-rule}, pattern variables that occur in the template
are replaced by the subforms they match in the input. Pattern variables
that occur in subpatterns followed by one or more instances of the
identifier ``...'' are allowed only in subtemplates that are followed by
as many instances of ``...''. They are replaced in the output by all of
the subforms they match in the input, distributed as indicated. It is an
error if the output cannot be built up as specified.

Identifiers that appear in the template but are not pattern variables or
the identifier ... are inserted into the output as literal
identifiers. If a literal identifier is inserted as a free identifier
then it refers to the binding of that identifier within whose scope the
instance of @code{syntax-rules} appears. If a literal identifier is
inserted as a bound identifier then it is in effect renamed to prevent
inadvertent captures of free identifiers.
@end defspec

@defspec let-syntax @var{bindings} @var{body}
@var{bindings} should have the form
@example
((@var{keyword} @var{transformer-spec}) ...)
@end example
Each @var{keyword} is an identifier, each @var{transformer-spec} is an
instance of @code{syntax-rules}, and @var{body} should be a sequence of
one or more expressions. It is an error for a @var{keyword} to appear
more than once in the list of keywords being bound.

The @var{body} is expanded in the syntactic environment obtained by
extending the syntactic environment of the @code{let-syntax} expression
with macros whose keywords are the @var{keyword}'s, bound to the
specified transformers. Scope of binding of a @var{keyword} is @var{body}.

@example
(let-syntax ((when (syntax-rules ()
                     ((when test stmt1 stmt2 ...)
                      (if test
                          (begin stmt1
                                 stmt2 ...))))))
  (let ((if #t))
    (when if (set! if 'now))
    if))                    ==> now

(let ((x 'outer))
  (let-syntax ((m (syntax-rules () ((m) x))))
    (let ((x 'inner))
      (m))))                ==> outer
@end example
@end defspec

@defspec letrec-syntax @var{bindings} @var{body}
The @var{body} is expanded in the syntactic environment obtained by
extending the syntactic environment of the @code{letrec-syntax}
expression with macros whose keywords are the @var{keyword}'s, bound to
the specified transformers. Scope of each binding of a @var{keyword} is
the @var{bindings} as well as the @var{body}, so the transformers can
transcribe expressions into uses of the macros introduced by the
@code{letrec-syntax} expression.

@example
(letrec-syntax
  ((my-or (syntax-rules ()
            ((my-or) #f)
            ((my-or e) e)
            ((my-or e1 e2 ...)
             (let ((temp e1))
               (if temp
                   temp
                   (my-or e2 ...)))))))
  (let ((x #f)
        (y 7)
        (temp 8)
        (let odd?)
        (if even?))
    (my-or x
           (let temp)
           (if y)
           y)))       ==> 7
@end example
@end defspec

@c ****************** Delayed Evaluation ****************
@node Delayed Evaluation, Equivalence, Macro, Standard Package
@section Delayed Evaluation
@defspec delay @var{expression}
The @code{delay} construct is used together with the procedure
@code{force} to implement @emph{lazy evaluation} or @emph{call by need.}
(@code{delay} @var{expression}) returns an object called a
@emph{promise} which at some point in the future may be asked (by the
@code{force} procedure) to evaluate @var{expression}, and deliver the
resulting value.
@end defspec

@defun force @var{promise}
Forces the value of @var{promise}. If no value has been computed for the
promise, then a value is computed and returned. The value of the promise
is cached (or ``memoized'') so that if it is forced a second time, the
previously computed value is returned.

@example
(force (delay (+ 1 2)))       ==> 3
(let ((p (delay (+ 1 2))))
  (list (force p) (force p))  ==> (3 3)

(define a-stream
  (letrec ((next
            (lambda (n)
              (cons n (delay (next (+ n 1)))))))
    (next 0)))
(define head car)
(define tail
  (lambda (stream) (force (cdr stream))))
(head (tail (tail a-stream))) ==> 2
@end example

@code{force} and @code{delay} are mainly intended for programs written
in functional style. The following examples should not be considered to
illustrate good programming style, but they illustrate the property that
only one value is computed for a promise, no matter how many times it is
forced. 

@example
(define count 0)
(define p
  (delay (begin (set! count (+ count 1))
                (if (> count x)
                    count
                    (force p)))))
(define x 5)
p                         ==> #<promise>
(force p)                 ==> 6
p                         ==> #<promise>
(begin (set! x 10)
       (force p))         ==> 6
@end example

@end defun

@c ****************** Equivalence *****************
@node Equivalence, Numerical Operations, Delayed Evaluation, Standard Package
@section Equivalence

@defun eqv? @var{obj1} @var{obj2}
The @code{eqv?} procedure defines a useful equivalence relation on
objects. Briefly, it returns @code{#t} if @var{obj1} and @var{obj2}
should normally be regarded as the same object. This relation is left
slightly open to interpretation, but the following partial specification
of @code{eqv?} holds for all implementations of Scheme

The @code{eqv?} procedure returns @code{#t} if:

@itemize @bullet
@item
@var{obj1} and @var{obj2} are both @code{#t} or both @code{#f}

@item
@var{obj1} and @var{obj2} are both symbols and
@example
(string=? (symbol->string obj1)
          (symbol->string obj2))
                            ==> #t
@end example

@item
@var{obj1} and @var{obj2} are both numbers, are numerically equal, and
are either both exact or both inexact.

@item
@var{obj1} and @var{obj2} are both characters and are the same
characters according to the @code{char=?} procedure.

@item
both @var{obj1} and @var{obj2} are the empty list.

@item
@var{obj1} and @var{obj2} are pairs, vectors, and strings that denote
the same locations in the store.

@item 
@var{obj1} and @var{obj2} are procedures whose location tags are equal.
@end itemize

The @code{eqv?} procedure returns @code{#f} if:

@itemize @bullet
@item
@var{obj1} and @var{obj2} are of different types.

@item
one of @var{obj1} and @var{obj2} is @code{#t} but the other is
@code{#f}.

@item
@var{obj1} and @var{obj2} are both symbols but
@example
(string=? (symbol->string obj1)
          (symbol->string obj2))
                            ==> #f
@end example

@item
one of @var{obj1} and @var{obj2} is an exact number but the other is an
inexact number.

@item
@var{obj1} and @var{obj2} are numbers for which the @code{=} procedure
returns @code{#f}.

@item
@var{obj1} and @var{obj2} are characters for which the @code{char=?}
procedure returns @code{#f}.

@item
one of @var{obj1} and @var{obj2} is the empty list but the other is not.

@item
@var{obj1} and @var{obj2} are pairs, vectors, or strings that denote
distinct locations.

@item
@var{obj1} and @var{obj2} are procedures that would behave differently
(return different value or have different side effects) for some arguments.

@end itemize

@example
(eqv? 'a 'a)      ==> #t
(eqv? 'a 'b)      ==> #f
(eqv? 2 2)        ==> #t
(eqv? '() '())    ==> #t
(eqv? 100000000 100000000)   ==> #t
(eqv? (cons 1 2) (cons 1 2)) ==> #f
(eqv? (lambda () 1)
      (lambda () 2))         ==> #f
(eqv? #f 'nil)               ==> #f
(let ((p (lambda (x) x)))
  (eqv? p p))                ==> #t
@end example

The following examples in KSM-Scheme illustrate cases in which the boave
rules do not fully specify the behavior of @code{eqv?}.

@example
(eqv? "" "")                 ==> #f in KSM-Scheme
(eqv? '#() '#())             ==> #f in KSM-Scheme
(eqv? (lambda (x) x)
      (lambda (x) x))        ==> #f in KSM-Scheme
(eqv? (lambda (x) x)
      (lambda (y) y))        ==> #f in KSM-Scheme
@end example
@end defun

@defun eq? @var{obj1} @var{obj2}
@code{eq?} is similar to @code{eqv?} except that in some cases it is
capable of discerning distinctions finer than those detectable by
@var{eqv?}.

@code{eq?} and @code{eqv?} are guaranteed to have the same behavior on
symbols, booleans, the empty list, pairs, procedures, and non-empty
strings and vectors. @code{eq?}'s behavior on numbers and characters is
implementation-dependent, but it will always return either true or
false, and will return true only when @code{eqv?} would also return
true. @code{eq?} may also behave differently from @code{eqv?} on empty
vectors and empty strings.

@example
(eq? 'a 'a)           ==> #t
(eq? '(a) '(a))       ==> #f in KSM-Scheme
(eq? (list 'a) (list 'a))  ==> #f
(eq? "a" "a")         ==> #f in KSM-Scheme
(eq? "" "")           ==> #f in KSM-Scheme
(eq? '() '())         ==> #t
(eq? 2 2)             ==> #f in KSM-Scheme
(eq? #\A #\A)         ==> #f in KSM-Scheme
(eq? car car)         ==> #t
(let ((n (+ 2 3)))
  (eq? n n))          ==> #t in KSM-Scheme
(let ((x '(a)))
  (eq? x x))          ==> #t
(let ((x '#()))
  (eq? x x))          ==> #t
(let ((p (lambda (x) x)))
  (eq? x x))          ==> #t
@end example
@end defun

@defun equal? @var{obj1} @var{obj2}
@code{equal?} recursively compares the contents of pairs, vectors, and
strings, applying @code{eqv?} on other objects such as numbers and
symbols. A rule of thumb is that objects are generally @code{equal?} if
they print the same. @code{equal?} may fail to terminate if its
arguments are circular data structures.

@example
(equal? 'a 'a)        ==> #t
(equal? '(a) '(a))    ==> #t
(equal? '(a (b) c)
        '(a (b) c))   ==> #t
(equal? "abc" "abc")  ==> #t
(equal? 2 2)          ==> #t
(equal? (make-vector 5 'a)
        (make-vector 5 'a))  ==> #t
(equal? (lambda (x) x)
        (lambda (y) y))      ==> #f in KSM-Scheme
@end example
@end defun

@c ****************** Numerical Operations *****************
@node Numerical Operations, Numerical I/O, Equivalence, Standard Package
@section Numerical Operations

@defun number? @var{obj}
@defunx complex? @var{obj}
@defunx real? @var{obj}
@defunx rational? @var{obj}
@defunx integer? @var{obj}
These numerical type predicates can be applied to any kind of argument,
including non-numbers. They return @code{#t} if the object is of the
named type, and otherwise they return @code{#f}. In general, if a type
predicate is true of a number then all higher type predicates are also
true of that number. Consequently, if a type predicate is false of a
number, then all lower type predicates are also false of that number.

If @var{z} is an inexact complex number, then (@code{real?} @var{z}) is
true if and only if (@code{zero?} (@code{imag-part} @var{z})) is
true. If @var{x} is an inexact real number, then (@code{integer?}
@var{x}) is true if and only if (@code{=} @var{x} (@code{round}
@var{x})).

@example
(complex? 3+4i)         ==> #t
(complex? 3)            ==> #t
(real? 3)               ==> #t
(real? -2.5+0.0i)       ==> #t
(real? #e1e10)          ==> #t
(rational? 6/10)        ==> #t
(rational? 6/3)         ==> #t
(integer? 3+0i)         ==> #t
(integer? 3.0)          ==> #t
(integer? 8/4)          ==> #t
(integer? 6)            ==> #t
@end example
@end defun

@defun exact? @var{z}
@defunx inexact? @var{z}
These numerical predicates provide tests for the exactness of a
quantity. For any Scheme number, precisely one of these predicates is
true.

@example
(exact? 1)              ==> #t
(exact? 1/2)            ==> #t
(exact? 1.2)            ==> #f
(exact? 1.0)            ==> #f
(inexact? 1.2)          ==> #t
(inexact? 1.0+2.0i)     ==> #t
(inexact? 1)            ==> #f
@end example
@end defun

@defun = @var{z1} @var{z2} @var{z3} ...
@defunx < @var{x1} @var{x2} @var{x3} ...
@defunx > @var{x1} @var{x2} @var{x3} ...
@defunx <= @var{x1} @var{x2} @var{x3} ...
@defunx >= @var{x1} @var{x2} @var{x3} ...
These procedures return @code{#t} if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing, monotonically
nondecreasing, or monotonically noincreasing.
@end defun

@defun zero? @var{z}
@defunx positive? @var{x}
@defunx negative? @var{x}
@defunx odd? @var{n}
@defunx even? @var{n}
These numerical predicates test a number for a particular property,
returning @code{#t} or @code{#f}.
@end defun

@defun max @var{x1} @var{x2} ...
@defunx min @var{x1} @var{x2} ...
These procedures return the maximum or minimum of their arguments.

@example
(max 3 4)        ==> 4
(max 3.9 4)      ==> 4 in KSM-Scheme
@end example
@end defun

@defun + @var{z1} ...
@defunx * @var{z1} ...
These procedures return the sum or product of their arguments.

@example
(+ 3 4)          ==> 7
(+ 3)            ==> 3
(* 4)            ==> 4
(*)              ==> 1
@end example
@end defun

@defun - @var{z1} @var{z2}
@defunx - @var{z}
@defunx - @var{z1} @var{z2} ...
@defunx / @var{z1} @var{z2}
@defunx / @var{z}
@defunx / @var{z1} @var{z2} ...
With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left. With one argument,
however, they return the additive or multiplicative inverse of their
argument.

@example
(- 3 4)           ==> -1
(- 3 4 5)         ==> -6
(- 3)             ==> -3
(/ 3 4 5)         ==> 3/20
(/ 3)             ==> 1/3
@end example
@end defun

@defun abs @var{x}
@code{abs} returns the absolute value of its argument.

@example
(abs -7)          ==> 7
@end example
@end defun

@defun quotient @var{n1} @var{n2}
@defunx remainder @var{n1} @var{n2}
@defunx modulo @var{n1} @var{n2}
These procedures implement number-theoretic (integer) division. n2
should be non-zero. All three procedures return integers. If n1/n2 is an
integer:

@example
(quotient n1 n2)  ==> n1/n2
(remainder n1 n2) ==> 0
(modulo n1 n2)    ==> 0
@end example

If n1/n2 is not an integer

@example
(quotient n1 n2)  ==> nq
(remainder n1 n2) ==> nr
(modulo n1 n2)    ==> nm
@end example

where nq is n1/n2 rounded towards zero, 0 < |nr| < |n2|, 0 < |nm| <
|n2|, nr and nm differ from n1 by a multiple of n2, nr has the same sign
as n1, and nm has the same sign as n2.

From this we can conclude that for integers n1 and n2 with n2 not equal
to 0,

@example
(= n1 (+ (* n2 (quotient n1 n2))
         (remainder n1 n2)))
                  ==> #t
@end example

provided all numbers involved in that computation are exact.

@example
(modulo 13 4)      ==> 1
(remainder 13 4)   ==> 1
(modulo -13 4)     ==> 3
(remainder -13 4)  ==> -1
(modulo 13 -4)     ==> -3
(remainder 13 -4)  ==> 1
(modulo -13 -4)    ==> -1
(remainder -13 -4) ==> -1
(remainder -13 -4.0) ==> -1.0  ; inexact
@end example
@end defun

@defun gcd @var{n1} ...
@defunx lcm @var{n1} ...
These procedures return the greatest common divisor or least common
multiple of their arguments. The result is always non-negative.  In
KSM-Scheme, each argument to these procedures should be an integer.

@example
(gcd 32 -36)      ==> 4
(gcd)             ==> 9
(lcm 32 -36)      ==> 288
(lcm 32.0 -36)    ==> #<error> in KSM-Scheme
(lcm)             ==> 1
@end example
@end defun

@defun numerator @var{q}
@defunx denominator @var{q}
These procedures return the numerator or denominator of their argument;
the result is computed as if the argument was represented as a fraction
in lowest terms. The denominator is always positive. The denominator of
0 is defined to be 1. In KSM-Scheme, each argument should be an integer
or a rational number.

@example
(numerator (/ 6 4))   ==> 3
(denominator (/ 6 4)) ==> 2
(denominator
  (exact->inexact (/ 6 4))) ==> #<error> in KSM-Scheme
@end example
@end defun

@defun floor @var{x}
@defunx ceiling @var{x}
@defunx truncate @var{x}
@defunx round @var{x}
These procedures return integers. @code{floor} returns the largest
integer not larger than @var{x}. @code{ceiling} returns the smallest
integer not smaller than @var{x}. @code{truncate} returns the integer
closest to @var{x} whose absolute value is not larger than the absolute
value of @var{x}. If @var{x} is halfway between two integers,
@code{round} returns the one with larger absolute value. This behavior
is in accord with @code{rint()} in C library, and is different from
Scheme Standard which states that @code{round} returns the even integer.

@example
(floor -4.3)     ==> -5.0
(ceiling -4.3)   ==> -4.0
(truncate -4.3)  ==> -4.0
(round -4.3)     ==> -4.0

(floor 3.5)      ==> 3.0
(ceiling 3.5)    ==> 4.0
(truncate 3.5)   ==> 3.0
(round 3.5)      ==> 4.0  ; inexact
(round 4.5)      ==> 5.0 in KSM-Scheme (it is 4.0 in Scheme Standard)
(round 7/2)      ==> 4.0  ; exact
(round 7)        ==> 7
@end example
@end defun

@defun rationalize @var{x} @var{y}
@code{rationalize} procedure is not supported in KSM-Scheme. It is an
error to call this procedure.
@end defun

@defun exp @var{z}
@defunx log @var{z}
@defunx sin @var{z}
@defunx cos @var{z}
@defunx tan @var{z}
@defunx asin @var{z}
@defunx acos @var{z}
@defunx atan @var{z}
@defunx atan @var{y} @var{x}
These procedures compute the usual transcendental functions. @code{log}
computes the natural logarithm of @var{z} (not the base ten
logarithm).
@end defun

@defun sqrt @var{z}
Returns the square root of @var{z}.
@end defun

@defun expt @var{z1} @var{z2}
Returns @var{z1} raised to the power @var{z2}.
@end defun

@defun make-rectangular @var{x} @var{y}
@defunx make-polar @var{r} @var{theta}
@defunx real-part @var{z}
@defunx imag-part @var{z}
@defunx magnitude @var{z}
@defunx angle @var{z}
Suppose x, y, r, theta are real numbers and z is a complex number such
that z = x + y*i = r*exp(theta*i), then
@example
(make-rectangular x y)    ==> z
(make-polar r theta)      ==> z
(real-part z)             ==> x
(imag-part z)             ==> y
(magnitude z)             ==> |r|
(angle z)                 ==> theta
@end example
unit of theta is radian.
@end defun

@defun exact->inexact @var{z}
@defunx inexact->exact @var{z}
@code{exact->inexact} returns an inexact representation of @var{z}. The
value returned is the inexact number that is numerically closest to the
argument. If @var{z} is an inexact number, it returns @var{z}.

@code{inexact->exact} returns an exact representation of @var{z}. The
value returned is the exact number that is numerically closest to the
argument. If @var{z} is an exact number, it returns @var{z}.
@end defun

@c ***************** Numerical I/O *****************
@node Numerical I/O, Booleans, Numerical Operations, Standard Package
@section Numerical I/O
@defun number->string @var{z}
@defunx number->string @var{z} @var{radix}
@var{radix} must be an exact integer, either 2, 8, 10, or 16. If
omitted, @var{radix} defaults to 10. The procedure @code{number->string}
takes a number and a radix and returns as a string an external
representation of the given number in the given radix such that
@example
(let ((number n)
      (radix r))
  (eqv? number
        (string->number (number->string number radix)
                        radix)))
@end example
is true.

If @var{z} is other than an integer, the radix shoule be 10.

The result returned by @code{number->string} never contains an explicit
radix prefix.

@example
(number->string 100)    ==> "100"
(number->string 100 2)  ==> "1100100"
(number->string 100 8)  ==> "144"
(number->string 100 16) ==> "64"
@end example
@end defun

@defun string->number @var{string}
@defunx string->number @var{string} @var{radix}
Returns a number of the maximally precise representation expressed by
the given @var{string}. @var{string} should not have an radix
prefix. @var{radix} must be an exact integer, either 2, 8, 10, or 16. If
omitted, @var{radix} defaults to 10. If @var{string} represents a number
other than integer, @var{radix} should be 10.  If @var{string} does not
represent valid a number, then @code{string->number} returns @code{#f}.

@example
(string->number "64" 16)     ==> 100
(string->number "1100100" 2) ==> 100
(string->number "hello")     ==> #f
@end example
@end defun

@c ****************** Booleans *********************
@node Booleans, Pairs and Lists, Numerical I/O, Standard Package
@section Booleans
@defun not @var{obj}
Returns @code{#t} if @var{obj} is false, and returns @code{#f}
otherwise.

@example
(not #t)            ==> #f
(not 3)             ==> #f
(not (list 3))      ==> #f
(not #f)            ==> #t
(not '())           ==> #f
(not (list))        ==> #f
(not 'nil)          ==> #f
@end example
@end defun

@defun boolean? @var{obj}
Returns @code{#t} if @var{obj} is either @code{#t} or @code{#f}, and
returns @code{#f} otherwise.

@example
(boolean? #f)      ==> #t
(boolean? #t)      ==> #t
(boolean? 0)       ==> #f
(boolean '())      ==> #f
@end example
@end defun

@c ****************** Pairs and Lists *************
@node Pairs and Lists, Symbol, Booleans, Standard Package
@section Pairs and Lists
@defun pair? @var{obj}
Returns @code{#t} if @var{obj} is a pair, and otherwise returns
@code{#f}.

@example
(pair? '(a . b))   ==> #t
(pair? '(a b c))   ==> #t
(pair? '())        ==> #f
(pair? '#(a b))    ==> #f
@end example
@end defun

@defun cons @var{obj1} @var{obj2}
Returns a newly allocated pair whose car is @var{obj1} and whose cdr is
@var{obj2}. The pair is guaranteed to be different (in the sense of
@code{eqv?}) from every existing object.

@example
(cons 'a '())         ==> (a)
(cons '(a) '(b c d))  ==> ((a) b c d)
(cons "a" '(b c))     ==> ("a" b c)
(cons 'a 3)           ==> (a . 3)
(cons '(a b) 'c)      ==> ((a b) . c)
@end example
@end defun

@defun car @var{pair}
Returns the content of the car field of @var{pair}. Note that it is an
error to take the car of the empty list.

@example
(car '(a b c))        ==> a
(car '((a) b c d))    ==> (a)
(car '(1 . 2))        ==> 1
(car '())             ==> #<error>
@end example
@end defun

@defun cdr @var{pair}
Returns the content of the cdr field of @var{pair}. Note that it is an
error to take the cdr of the empty list.

@example
(cdr '((a) b c d))    ==> (b c d)
(cdr '(1 . 2))        ==> 2
(cdr '())             ==> #<error>
@end example
@end defun

@defun set-car! @var{pair} @var{obj}
Stores @var{obj} in the car field of @var{pair}. The value returned by
@code{set-car!} is unspecified.

@example
(define p (cons 1 2))
p                     ==> (1 . 2)
(set-car! p 3)   
p                     ==> (3 . 2)
@end example
@end defun

@defun set-cdr! @var{pair} @var{obj}
Stores @var{obj} in the cdr field of @var{pair}. The value returned by
@code{set-cdr!} is unspecified.
@end defun

@defun caar @var{pair}
@defunx cadr @var{pair}
  ...
@defunx cdddar @var{pair}
@defunx cddddr @var{pair}
These procedures are compositions of @code{car} and @code{cdr}, where
for example @code{caddr} could be defined by
@example
(define caddr (lambda (x) (car (cdr (cdr x)))))
@end example
Arbitrary compositions, up to four deep, are provided. There are
twenty-eight of these procedures in all.

@example
(caar '((a b) (c d)))   ==> a
(cdadr '((a b) (c d)))  ==> (d)
@end example
@end defun

@defun null? @var{obj}
Returns @code{#t} if @var{obj} is the empty list, otherwise returns
@code{#f}.

@example
(null? '())        ==> #t
(null? '(1))       ==> #f
(null? 'a)         ==> #f
@end example
@end defun

@defun list? @var{obj}
Returns @code{#t} if @var{obj} is a list, otherwise returns
@code{#f}. By definition, all lists have finite length and are
terminated by the empty list.

@example
(list? '(a b c))   ==> #t
(list? '())        ==> #t
(list? '(a . b))   ==> #f
(let ((x (list 'a)))
  (set-cdr! x x)
  (list? x))       ==> #f
@end example
@end defun

@defun list @var{obj} ...
Returns a newly allocated list of its arguments.

@example
(list 'a (+ 3 4) 'c)    ==> (a 7 c)
(list)                  ==> ()
@end example
@end defun

@defun length @var{list}
Returns the length of @var{list}.

@example
(length '(a b c))          ==> 3
(length '(a (b) (c d e)))  ==> 3
(length '())               ==> 0
@end example
@end defun

@defun append @var{list} ...
Returns a list consisting of the elements of the first @var{list}
followed by the elements of the other @var{lists}.

@example
(append '(x) '(y))         ==> (x y)
(append '(a) '(b c d))     ==> (a b c d)
(append '(a (b)) '((c)))   ==> (a (b) (c))
@end example

The resulting list is always newly allocated, except that it shares
structure with the last @var{list} argument. The last argument may
actually be any object; an improper list results if the last argument is
not a proper list.

@example
(append '(a b) '(c . d))   ==> (a b c . d)
(append '() 'a)            ==> a
@end example
@end defun

@defun reverse @var{list}
Returns a newly allocated list consisting of the elements of @var{list}
in reverse order.

@example
(reverse '(a b c))              ==> (c b a)
(reverse '(a (b c) d (e (f))))  ==> ((e (f)) d (b c) a)
@end example
@end defun

@defun list-tail @var{list} @var{k}
Returns the sublist of @var{list} obtained by omitting the first @var{k}
elements. It is an error if @var{list} has fewer than @var{k} elements.

@example
(list-tail '(1 2 3 4 5) 2)      ==> (3 4 5)
(list-tail '(1 2 3 4 5) 0)      ==> (1 2 3 4 5)
(list-tail '(1 2 3 4 5) 5)      ==> ()
(list-tail '(1 2 3 4 5) 6)      ==> #<error>
@end example
@end defun

@defun list-ref @var{list} @var{k}
Returns the @var{k}-th element of @var{list}. The 0-th element implies
the first element.  It is an error if @var{list} has fewer than @var{k}
elements.

@example
(list-ref '(1 2 3 4 5) 0)   ==> 1
(list-ref '(1 2 3 4 5) 2)   ==> 3
@end example
@end defun

@defun memq @var{obj} @var{list}
@defunx memv @var{obj} @var{list}
@defunx member @var{obj} @var{list}
These procedures return the first sublist of @var{list} whose car is
@var{obj}, where the sublists of @var{list} are the non-empty lists
returned by (list-tail list k) for k less than the length of list. If
@var{obj} does not occur in @var{list}, then @code{#f} (not the empty
list) is returned. @code{memq} uses @code{eq?} to compare @var{obj} with
the elements of @var{list}, while @code{memv} uses @code{eqv?} and
@code{member} uses @code{equal?}.

@example
(memq 'a '(a b c))          ==> (a b c)
(memq 'b '(a b c))          ==> (b c)
(memq 'a '(b c d))          ==> #f
(memq (list 'a) '(b (a) c)) ==> #f
(member (list 'a)
        '(b (a) c))         ==> ((a) c)
(memq 101 '(100 101 102))   ==> #f in KSM-Scheme
(memv 101 '(100 101 102))   ==> (101 102)
@end example
@end defun

@defun assq @var{obj} @var{alist}
@defunx assv @var{obj} @var{alist}
@defunx assoc @var{obj} @var{alist}
@var{alist} (for ``association list'') must be a list of pairs. These
procedures find the first pair in @var{alist} whose car field is
@var{obj}, and returns that pair. If no pair in @var{alist} has
@var{obj} as its car, then @code{#f} (not the empty list) is
returned. @code{assq} uses @code{eq?} to compare @code{obj} with the car
fields of the pairs in @var{alist}, while @code{assv} uses @code{eqv?}
and @code{assoc} uses @code{equal?}.

@example
(define e '((a 1) (b 2) (c 3)))
(assq 'a e)              ==> (a 1)
(assq 'b e)              ==> (b 2)
(assq 'd e)              ==> #f
(assq (list 'a) '(((a)) ((b)) ((c))))
                         ==> #f
(assoc (list 'a) '(((a)) ((b)) ((c))))
                         ==> ((a))
(assq 5 '((2 3) (5 7) (11 13)))
                         ==> #f in KSM-Scheme
(assv 5 '((2 3) (5 7) (11 13)))
                         ==> (5 7)
@end example
@end defun

@c ****************** Symbol *********************
@node Symbol, Std-Character, Pairs and Lists, Standard Package
@section Symbol
@defun symbol? @var{obj}
Returns @code{#t} if @var{obj} is a symbol, otherwise returns @code{#f}.

@example
(symbol? 'foo)         ==> #t
(symbol? (car '(a b))) ==> #t
(symbol? "bar")        ==> #f
(symbol? 'nil)         ==> #t
(symbol? '())          ==> #f
(symbol? #f)           ==> #f
@end example
@end defun

@defun symbol->string @var{symbol}
Returns the name of @var{symbol} as a string. KSM-Scheme is
case-sensitive. Therefore, case of each character in the @var{symbol} is
preserved in the returned string.

@example
(symbol->string 'flying-fish)  ==> "flying-fish"
(symbol->string 'Martin)       ==> "Martin" in KSM-Scheme
(symbol->string 
  (string->symbol "Malvina"))  ==> "Malvina"
@end example
@end defun

@defun string->symbol @var{string}
Returns the symbol whose name is @var{string}.

@example
(eq? 'mISSISSIpi 'mississippi)  ==> #f in KSM-Scheme
(string->symbol "mISSISSIppi")  ==> mISSISSIppi
(eq? 'bitBLT (string->symbol "bitBLT"))
                                ==> #t in KSM-Scheme
(eq? 'JollyWog
     (string->symbol
       (symbol->string 'JollyWog)))
                                ==> #t
(string=? "K. Harper, M.D."
          (symbol->string
            (string->symbol "K. Harper, M.D.")))
                                ==> #t
@end example
@end defun

@c ******************* Character ******************
@node Std-Character, Std-String, Symbol, Standard Package
@section Character
@defun char? @var{obj}
Returns @code{#t} if @var{obj} is a character, otherwise returns
@code{#f}.
@end defun

@defun char=? @var{char1} @var{char2}
@defunx char<? @var{char1} @var{char2}
@defunx char>? @var{char1} @var{char2}
@defunx char<=? @var{char1} @var{char2}
@defunx char>=? @var{char1} @var{char2}
These procedures impose a total ordering on the set of characters. In
KSM-Scheme, the ordering represents the Unicode code value of the
characters.
@end defun

@defun char-ci=? @var{char1} @var{char2}
@defunx char-ci<? @var{char1} @var{char2}
@defunx char-ci>? @var{char1} @var{char2}
@defunx char-ci<=? @var{char1} @var{char2}
@defunx char-ci>=? @var{char1} @var{char2}
These procedures are similar to @code{char=?} et cetera, but they treat
upper case and lower case letters as the same. In KSM-Scheme, case of
characters outside the ASCII range (outside 0x00-0x7f) is handled
properly. 

@example
(char-ci=? #\A #\a)             ==> #t
(char-ci=? #\U@{2174@} #\U@{2164@}) ==> #t
@end example
@end defun

@defun char-alphabetic? @var{char}
@defunx char-numeric? @var{char}
@defunx char-whitespace? @var{char}
@defunx char-upper-case? @var{char}
@defunx char-lower-case? @var{char}
These procedures return @code{#t} if their arguments are alphabetic,
numeric, whitespace, upper case, or lower case characters, respectively,
otherwise they return @code{#f}. In KSM-Scheme, @code{char-alphabetic?},
@code{char-numeric?}, and @code{char-whitespace?} currently support
characters in the ASCII range (0x00 through 0x7f). For characters
outside this range, they return @code{#f}. @code{char-upper-case?} and
@code{char-lower-case?} support all the Unicode characters.

@example
(char-alphabetic? #\a)     ==> #t
(char-numeric? #\2)        ==> #t
(char-whitespace #\space)  ==> #t
(char-upper-case? #\A)     ==> #t
(char-lower-case? #\a)     ==> #t
@end example
@end defun

@defun char->integer @var{char}
@defunx integer->char @var{n}
Given a character, @code{char->integer} returns an integer that is the
Unicode code value of the character.  Given an integer,
@code{integer->char} interpretes the number as a Unicode code value and
returns a character corresponding to that code.

@example
(char->integer #\a)   ==> 97
(integer->char 90)    ==> #\Z
@end example
@end defun

@defun char-upcase @var{char}
@defunx char-downcase @var{char}
@code{char-upcase} returns the upper case of the @var{char} if there is
one, otherwise returns the @var{char} itself.  @code{char-downcase}
returns the lower case of the @var{char} if there is one, otherwise
returns the @var{char} itself. Both procedures support all Unicode
characters.
@end defun

@c **************** String ******************
@node Std-String, Std-Vector, Std-Character, Standard Package
@section String
@defun string? @var{obj}
Returns @code{#t} if @var{obj} is a string, otherwise returns @code{#f}.

@example
(string? "abc")   ==> #t
(string? 'abc)    ==> #f
@end example
@end defun

@defun make-string @var{k}
@defunx make-string @var{k} @var{char}
@code{make-string} returns a newly allocated string of length
@var{k}. If @var{char} is given, then all elements of the string are
initialized to @var{char}, otherwise the contents of the @var{string}
are unspecified except its length.

@example
(make-string 3 #\a)  ==> "aaa"
@end example
@end defun

@defun string @var{char} ...
Returns a newly allocated string composed of the arguments.

@example
(string #\h #\e #\l #\l #\o)  ==> "hello"
@end example
@end defun

@defun string-length @var{string}
Returns the number of characters in the given @var{string}. 

@example
(string-length "abcdefg")   ==> 7
@end example
@end defun

@defun string-ref @var{string} @var{k}
@var{k} must be a valid index of @var{string} (that is, 0 <= @var{k} and
@var{k} < length of @var{string}). @code{string-ref} returns character
@var{k} of @var{string} using zero-origin indexing.

@example
(string-ref "abcdefg" 0)  ==> #\a
(string-ref "abcdefg" 2)  ==> #\c
(string-ref "abcdefg" 7)  ==> #<error>
@end example
@end defun

@defun string-set! @var{string} @var{k} @var{char}
@var{k} must be a valid index of @var{string} (that is, 0 <= @var{k} and
@var{k} < length of @var{string}). @code{string-set!} stores @var{char}
in element @var{k} (zero-origin indexing) and returns an unspecified
value.

@example
(define str "abcdefg")
str                       ==> "abcdefg"
(string-set! str 2 #\X)   ==> #<unspecified>
str                       ==> "abXdefg"
@end example
@end defun

@defun string=? @var{string1} @var{string2}
@defunx string-ci=? @var{string1} @var{string2}
@code{string=?} returns @code{#t} if the two strings are the same length
and contain the same characters in the same positions, otherwise returns
@code{#f}. @code{string-ci=?} is similar to @var{string=?} except that
it treats upper and lower case letters as though they were the same
character. @code{string-ci=?} supports all Unicode characters.

@example
(string=? "abcdefg" "abcdefg")     ==> #t
(string=? "ABCdefg" "abcdefg")     ==> #f
(string-ci=? "ABCdefg" "abcdefg")  ==> #t
@end example
@end defun

@defun string<? @var{string1} @var{string2}
@defunx string>? @var{string1} @var{string2}
@defunx string<=? @var{string1} @var{string2}
@defunx string>=? @var{string1} @var{string2}
@defunx string-ci<? @var{string1} @var{string2}
@defunx string-ci>? @var{string1} @var{string2}
@defunx string-ci<=? @var{string1} @var{string2}
@defunx string-ci>=? @var{string1} @var{string2}
These procedures compares the ordering of the two @var{strings} and
returns @var{#t} or @var{#f}. For example, @code{string<?} uses the
lexicographic ordering on strings induced by the ordering @code{char<?}
on characters. If two strings differ in length but are the same up to
the length of the shorter string, the shorter string is considered to be
lexicographically less than the longer string.

@example
(string<?  "ABCDEFG" "abcdefg")     ==> #f
(string-ci<?  "ABCDEFG" "abcdefg")  ==> #t
@end example
@end defun

@defun substring @var{string} @var{start} @var{end}
@var{string} must be a string, and @var{start} and @var{end} must be
integers satisfying
@example
0 <= @var{start} <= @var{end} <= length of @var{string}
@end example
@code{substring} returns a newly allocated string formed from the
characters of @var{string} beginning with index @var{start} (inclusive)
and ending with index @var{end} (exclusive).

@example
(substring "abcdefg" 2 4) ==> "cd"
(substring "abcdefg" 0 7) ==> "abcdefg"
@end example
@end defun

@defun string-append @var{string} ...
Returns a newly allocated string whose characters form the concatenation
of the given strings.

@example
(string-append "abc" "d" "efg")  ==> "abcdefg"
@end example
@end defun

@defun string->list @var{string}
@defunx list->string @var{list}
@code{string->list} returns a newly allocated list of the characters
that make up the given string. @code{list->string} returns a newly
allocated string formed from the characters in the @var{list}, which
must be a list of characters. @code{string->list} and
@code{list->string} are inverses so far as @code{equal?} is concerned.

@example
(string->list "hello")  ==> (#\h #\e #\l #\l #\o)
(list->string '(#\h #\e #\l #\l #\o))  ==> "hello"
@end example
@end defun

@defun string-copy @var{string}
Returns a newly allocated copy of the given @var{string}.

@example
(string-copy "abcdefg")                 ==> "abcdefg"
(eq? "abcdefg" (string-copy "abcdefg")) ==> #f
@end example
@end defun

@defun string-fill! @var{string} @var{char}
Stores @var{char} in every element of the given @var{string} and returns
an unspecified value.

@example
(define str "abcdefg")
str                     ==> "abcdefg"
(string-fill! str #\X)  ==> "XXXXXXX"
@end example
@end defun

@defun string->expr @var{string}
Reads a Scheme expression from @var{string} by the Scheme reader and
returns the expression.

@example
(string->expr "10")      ==> 10 
(string->expr "(a b c)") ==> (a b c)
@end example

@source{base/base.c}
@use{none}
@end defun

@c ****************** Vector ******************
@node Std-Vector, Std-Control-Features, Std-String, Standard Package
@section Vector
@defun vector? @var{obj}
Returns @code{#t} if @var{obj} is a vector, otherwise returns @code{#f}.

@example
(vector? '#(1 2 3))   ==> #t
(vector? '(1 2 3))    ==> #f
@end example
@end defun

@defun make-vector @var{k}
@defunx make-vector @var{k} @var{fill}
Returns a newly allocated vector of @var{k} elements. If a second
argument is given, then each element is initialized to
@var{fill}. Otherwise the initial contents of each element is
unspecified.

@example
(make-vector 3 #\a)   ==> #(a a a)
@end example
@end defun

@defun vector @var{obj} ...
Returns a newly allocated vector whose elements contain the given
arguments. Analogous to @code{list}.

@example
(vector 'a 'b 'c)     ==> #(a b c)
@end example
@end defun

@defun vector-length @var{vector}
Returns the number of elements in @var{vector} as an exact integer.

@example
(vector-length '#(a b c))   ==> 3
@end example
@end defun

@defun vector-ref @var{vector} @var{k}
@var{k} must be a valid index (zero-origin indexing) of
@var{vector}. @code{vector-ref} returns the contents of element @var{k}
of @var{vector}.

@example
(vector-ref '#(1 1 2 3 5 8 13 21) 5)
               ==> 8
(vector-ref '#(1 1 2 3 5 8 13 21) 0)
               ==> 1
@end example
@end defun

@defun vector-set! @var{vector} @var{k} @var{obj}
@var{k} must be a valid index (zero-origin indexing) of
@var{vector}. @code{vector-set!} stores @var{obj} in element @var{k} of
@var{vector}. The value returned by @code{vector-set!} is unspecified.

@example
(define vec (vector 0 '(2 2 2 2) "Anna"))
(vector-set! vec 1 '("Sue" "Sue"))
vec                  ==> #(0 ("Sue" "Sue") "Anna")
@end example
@end defun

@defun vector->list @var{vector}
@defunx list->vector @var{list}
@code{vector->list} returns a newly allocated list of the objects
contained in the elements of @var{vector}. @code{list->vector} returns a
newly created vector initialized to the elements of the @var{list}.

@example
(vector->list '#(dah dah didah))
               ==> (dah dah didah)
(list->vector '(dididit dah))
               ==> #(dididit dah)
@end example
@end defun

@defun vector-fill! @var{vector} @var{fill}
Stores @var{fill} in every element of @var{vector}. The value returned
by @code{vector-fill!} is unspecified.

@example
(define vec (vector 1 2 3))
(vector-fill! vec #\A)
vec            ==> #(A A A)
@end example
@end defun

@c ****************** Control Features ***************
@node Std-Control-Features, Std-Eval, Std-Vector, Standard Package
@section Control Features
@defun procedure? @var{obj}
Returns @code{#t} if @var{obj} is a procedure, otherwise returns
@code{#f}.

@example
(procedure? car)         ==> #t
(procedure? 'car)        ==> #f
(procedure? (lambda (x) (* x x)))
                         ==> #t
(procedure? '(lambda (x) (* x x)))
                         ==> #f
(call-with-current-continuation procedure?)
                         ==> #t
@end example
@end defun

@defun apply @var{proc} @var{arg1} ... @var{args}
@var{proc} must be a procedure and @var{args} must be a list. Calls
@var{proc} with the elements of the list (append (list @var{arg1} ...)
@var{args}) as the actual arguments.

@example
(apply + '(3 4))         ==> 7
(apply + 1 2 '(3 4))     ==> 10
(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))

((compose sqrt *) 12 75) ==> 30 ; (sqrt (* 12 75))
@end example
@end defun

@defun map @var{proc} @var{list1} @var{list2} ...
The @var{list}'s must be lists, and @var{proc} must be a procedure
taking as many arguments as there are @var{list}'s and returning a
single value. If more than one @var{list} is given, then they must all
be the same length. @code{map} applies @var{proc} element-wise to the
elements of the @var{list}'s and returns a list of the results, in
order. The order in which @var{proc} is applied to the elements of the
@var{list}'s is unspecified.

@example
(map cadr '((a b) (d e) (g h)))
            ==> (b e h)
(map (lambda (n) (expt n n))
     '(1 2 3 4 5))
           ==> (1 3 27 256 3125)
(map + '(1 2 3) '(4 5 6))  ==> (5 7 9)
@end example
@end defun

@defun for-each @var{proc} @var{list1} @var{list2} ...
The arguments to @code{for-each} are like the arguments to @code{map},
but @code{for-each} calls @var{proc} for its side effects rather than
for its values. Unlike @code{map}, @code{for-each} is guaranteed to call
@var{proc} on the elements of the @var{list}'s in order from the first
element to the last, and the value returned by @code{for-each} is
unspecified. 

@example
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)                   ==> #(0 1 4 9 16)
@end example
@end defun

@defun call-with-current-continuation @var{proc}
@defunx call/cc @var{proc}
@var{proc} must be a procedure of one argument. The procedure
@code{call-with-current-continuation} packages up the current
continuation as an ``escape procedure'' and passes it as an argument to
@var{proc}. The escape procedure is a Scheme procedure that, if it is
later called, will abandon whatever continuation is in effect at that
later time and will instead use the continuation that was in effect when
the escape procedure was created. Calling the escape procedure may cause
the invocation of @emph{before} and @emph{after} thunks installed using
@code{dynamic-wind}.

The escape procedure accepts the same number of arguments as the
continuation to the original call to
@code{call-with-current-continuation}. Except for continuations created
by the @code{call-with-values} procedure, all continuations take exactly
one value. The effect of passing no value or more than one value to
continuations that were not created by @code{call-with-values} is
unspecified.

The escape procedure that is passed to @var{proc} has unlimited extent
just like any other procedure in Scheme. It may be stored in variables
or data structures and may be called as many times as desired.

The following examples show only the most common ways in which
@code{call-with-current-continuation} is used. If all real uses were as
simple as these examples, there would be no need for a procedure with
the power of @code{call-with-current-continuation}.

@example
(call-with-current-continuation
  (lambda (exit)
    (for-each (lambda (x)
                (if (negative? x)
                    (exit x)))
              '(54 0 37 -3 245 19))
    #t))          ==> -3

(define list-length
  (lambda (obj)
    (call-with-current-continuation
      (lambda (return)
        (letrec ((r
                  (lambda (obj)
                    (cond ((null? obj) 0)
                          ((pair? obj)
                           (+ (r (cdr obj)) 1))
                          (else (return #f))))))
         (r obj))))))

(list-length '(1 2 3 4))  => 4

(list-length '(a b . c))  => #f
@end example

When feature of multithread programming is utilized @xref{Thread
Package}, there is a restriction in the usage of continuation: A
continuation (or escape procedure) can be invoked only from the thread
that packaged the continuation.

@example
(call/cc (lambda (cc) (cc 'ok))) ==> ok
(call/cc (lambda (cc) 
           (thread:create (lambda () (cc 'no)))))
                                 ==> #<error>
@end example

@end defun

@defun values @var{obj} ...
Delivers all of its arguments to its continuation. Except for
continuations created by the @code{call-with-values} procedure, all
continuations take exactly one value. 

@example
(values 1)      ==> 1
@end example
@end defun

@defun call-with-values @var{producer} @var{consumer}
Calls its @var{producer} argument with no values and a continuation
that, when passed some values, calls the @var{consumer} procedure with
those values as arguments. The continuation for the call to
@var{consumer} is the continuation of the call to
@code{call-with-values}.

@example
(call-with-values (lambda () (values 4 5))
                  (lambda (a b) b))
                            ==> 5

(call-with-values * -)      ==> -1
@end example

When the feature of multithread programming is utilized @xref{Thread
Package}, @code{values} should be called within the same thread that
created the continuation by @code{call-with-values}.

@example
(call/wv (lambda () (values 'ok))
         (lambda (a) a))   ==> ok
(call/wv (lambda () 
           (thread:create (lambda () (values 'no))))
         (lambda (a) a))   ==> #<error>
@end example
@end defun

@defun dynamic-wind @var{before} @var{thunk} @var{after}
Calls @var{thunk} without arguments, returning the result of this
call. @var{before} and @var{after} are called, also without arguments,
as required by the following rules (note that in the absence of calls to
continuations captured using @code{call-with-current-continuation} the
three arguments are called once each, in order). @var{before} is called
whenever execution enters the dynamic extent of the call to @var{thunk}
and @var{after} is called whenever it exits that dynamic extent. The
dynamic extent of a procedure call is the period between when the call
is initiated and when it returns. In Scheme, because of
@code{call-with-current-continuation}, the dynamic extent of a call may
not be a single, connected time period. It is defined as follows:

@itemize @bullet
@item
The dynamic extent is entered when execution of the body of the called
procedure begins.

@item
The dynamic extent is also entered when execution is not within the
dynamic extent and a continuation is invoked that was captured (using
@code{call-with-current-continuation} during the dynamic extent.

@item
It is exited when the called procedure returns.

@item
It is also exited when execution is within the dynamic extent and a
continuation is invoked that was captured while not within the dynamic
extent.

@end itemize

If a second call to @code{dynamic-wind} occurs within the dynamic extent
of the call to @var{thunk} and then a continuation is invoked in such a
way that the @var{after}'s from these two invocations of
@code{dynamic-wind} are both to be called, then the @var{after}
associated with the second (inner) call to @code{dynamic-wind} is called
first.

If a second call to @code{dynamic-wind} occurs within the dynamic extent
of the call to @var{thunk} and then a continuation is invoked in such a
way that the @var{before}'s from these two invocations of
@code{dynamic-wind} are both to be called, then the @var{before}
associated with the first (outer) call to @code{dynamic-wind} is called
first.

If invoking a continuation requires calling the @var{before} from one
call to @code{dynamic-wind} and the @var{after} from another, then the
@var{after} is called first.

The effect of using a captured continuation to enter or exit the dynamic
extent of a call to @var{before} or @var{after} is undefined.

@example
(let ((path '())
      (c #f))
  (let ((add (lambda (s)
        (set! path (cons s path)))))
    (dynamic-wind
     (lambda () (add 'connect))
     (lambda ()
       (add (call-with-current-continuation
              (lambda (c0)
                (set! c c0)
                'talk1))))
     (lambda () (add 'disconnect)))
    (if (< (length path) 4)
        (c 'talk2)
        (reverse path))))
  ==> (connect talk1 disconnect connect talk2 disconnect)
@end example
@end defun

@c ******************* Eval ********************
@node Std-Eval, Std-Port, Std-Control-Features, Standard Package
@section Eval
@defun eval @var{expression} [@var{environ}]
Evaluates @var{expression} in the specified environment and returns its
value. @var{expression} must be a valid Scheme expression represented as
data, and @var{environ} (if supplied) must be a value returned by one of
the three procedures described below. If @var{environ} is not supplied,
the @var{expression} is evaluated with the current top-level
environment, which is equivalent to the value returned by
@code{(interaction-environment)}.

@example
(eval '(* 7 3))                 ==> 21
(eval '(* 7 3) (scheme-report-environment 5))
                                ==> 21
(let ((f (eval '(lambda (f x) (f x x))
               (null-environment 5))))
  (f + 10))
                                ==> 
@end example
@end defun

@defun scheme-report-environment @var{version}
@defunx null-environment @var{version}
@var{version} must be the integer
@code{5}. @code{scheme-report-environment} returns an environment that
is empty except for all bindings defined in the Revised^5 Report on
Scheme. @code{null-environment} returns an environment that is empty
except for the bindings for all syntactic keywords defined in the
Revised^5 Report on Scheme. 
@end defun

@defun interaction-environment
This function returns the current top-level environment.
@end defun

@c ****************** Port *********************
@node Std-Port, Std-Input, Std-Eval, Standard Package
@section Port

Ports represent input and output devices. To Scheme, an input port is a
Scheme object that can deliver characters upon command, while an output
port is a Scheme object that can accept characters.

@defun call-with-input-file @var{string} [@var{encoding}] @var{proc}
@defunx call-with-output-file @var{string} [@var{encoding}] @var{proc}
@var{string} should be a string naming a file, and @var{proc} should be
a procedure that accepts one argument. For @code{call-with-input-file},
the file should already exist; for @code{call-with-output-file} the file
is truncated if the file already exists. These procedures cal @var{proc}
with one argument: the port obtained by opening the named file for input
or output. If the file cannot be opened, an error is signalled. If
@var{proc} returns, then the port is closed automatically and the value
yielded by the @var{proc} is returned. If @var{proc} does not return,
then the port will not be closed automatically unless it is possible to
prove that the port will never again be used.

Because Scheme's escape procedures have unlimited extent, it is possible
to escape from the current continuation but later to escape back in. If
implementations were permitted to close the port on any escape from the
current continuation, then it would be impossible to write portable code
using both @code{call-with-current-continuation} and
@code{call-with-input-file} or @code{call-with-output-file}.

If @var{encoding} is supplied, it should be a string that specifies the
character-set encoding of the input or output file. If it is omitted, it
defaults to "UTF-8", which is the internal encoding in KSM-Scheme.
Acceptable encoding methods are available from @code{iconv --list}.

Following expression converts a file encoded in SHIFT-JIS to a new file
encoded in EUC-JP.
@example
(call-with-output-file "dst.euc" "EUC-JP"
  (lambda (out)
    (call-with-input-file "src.sjis" "SHIFT-JIS"
      (lambda (in)
        (let loop ((ch (read-char in)))
             (if (not (eof-object? ch))
                 (begin
                   (write-char ch out)
                   (loop (read-char in)))))))))
@end example
@end defun

@defun input-port? @var{obj}
@defunx output-port? @var{obj}
Returns @code{#t} if @var{obj} is an input port or output port,
respectively; otherwise returns @code{#f}.
@end defun

@defun current-input-port
@defunx current-output-port
Returns the current default input or output port.
@end defun

@defun current-error-port
Returns a port which outputs accepted characters to the error stream
(``standard error'').

@source{base/base.c}
@use{none}
@end defun

@defun with-input-from-file @var{string} [@var{encoding}] @var{thunk}
@defunx with-output-to-file @var{string} [@var{encoding}] @var{thunk}
@var{string} should be a string naming a file, and @var{proc} should be
a procedure that accepts one argument. For @code{call-with-input-file},
the file should already exist; for @code{call-with-output-file} the file
is truncated if the file already exists. The file is opened for input or
output, an input or output port connected to it is made the default
value returned by @code{current-input-port} or
@code{current-output-port} (and is used by @code{(read)}, @code{(write
@var{obj})}, and so forth), and the @var{thunk} is called with no
arguments. When the @var{thunk} returns, the port is automatically
closed and the previous default is restored. @code{with-input-from-file}
and @code{with-output-to-file} return the value yielded by
@var{thunk}. If an escape procedure is used to escape from the
continuation of these procedures, the previous default is not restored.

If @var{encoding} is supplied, it should be a string that specifies the
encoding of the input or output file. If it is omitted, it defaults to
"UTF-8".

@example
(with-input-from-file "src.euc" "EUC-JP"
  (lambda () ...))

(with-output-to-file "dst.sjis" "SHIFT-JIS"
  (lambda () ...))
@end example
@end defun

@defun open-input-file @var{filename} [@var{encoding}]
@var{filename} should the name of an existing file. This function
returns an input port capable of delivering characters from the file. If
the file cannot be opened, an error is signalled.

If @var{encoding} is supplied, it should be a string that specifies the
character-set encoding of the input file. If it is omitted, it defaults
to "UTF-8".
@end defun

@defun open-output-file @var{filename} [@var{encoding}]
@var{filename} specifies the name of an output file. If a file with the
same name already exists, the file is truncated before opening. This
function returns an output port capable of writing characters to a new
file by that name. If the file cannot be opened or created, an error is
signalled. 

If @var{encoding} is supplied, it should be a string that specifies the
character-set encoding of the output file. If it is omitted, it defaults
to "UTF-8".
@end defun

@defun close-input-port @var{port}
@defunx close-output-port @var{port}
Closes the file associated with @var{port}, rendering the @var{port}
incapable of delivering or accepting characters. These routines have no
effect if the file has already been closed. The value returned is
unspecified. 
@end defun

@c ****************** Input *******************
@node Std-Input, Std-Output, Std-Port, Standard Package
@section Input

@defun read
@defunx read @var{port}
@code{read} converts external representations of Scheme objects into the
objects themselves. Therefore, it is a Scheme parser. @code{read}
returns the next object parsable from the given input @var{port},
updating @var{port} to point to the first character past the end of the
external representation of the object.

If an end of file is encountered in the input before any characters are
found that can begin an object, then an end of file object is
returned. The port remains open, and further attempts to read will also
return an end of file object. If an end of file is encountered after a
beginning of an object's external representation and the characters up
to the point consistute a complete representation, @code{read} returns
the corresponding object. Next time @code{read} is called, it returns an
end of file object. If an end of file is encountered after the beginning
of an object's external representation, but the external representation
is incomplete and therefore not parsable, an error is signalled. 

The @var{port} argument may be omitted, in which case it defaults to the
value returned by @code{current-input-port}. It is an error to read from
a closed port.
@end defun

@defun read-char
@defunx read-char @var{port}
Returns the next character available from the input @var{port}, updating
the @var{port} to point to the following character. If no more
characters are available, an end of file object is returned. @var{port}
may be omitted, in which case it defaults to the value returned by
@code{current-input-port}. 
@end defun

@defun peek-char
@defunx peek-char @var{port}
Returns the next character available from the input @var{port},
@emph{without} updating the @var{port} to point to the following
character. If no more characters are available, an end of file object is
returned. @var{port} may be omitted, in which case it defaults to the
value returned by @code{current-input-port}.
@end defun

@defun eof-object? @var{obj}
Returns @code{#t} if @var{obj} is an end of file object, otherwise
returns @code{#f}.
@end defun

@defun char-ready?
@defunx char-ready? @var{port}
Returns @code{#t} if a character is ready on the input @var{port} and
returns @code{#f} otherwise. If @code{char-ready?} returns @code{#t}
then the next @code{read-char} operation on the given @var{port} is
guaranteed not to hang. If the @var{port} is at end of file then
@code{char-ready?} returns @code{#t}. @var{port} may be omitted, in
which case it defaults to the value returned by
@code{current-input-port}.
@end defun

@defun readline [@var{port}]
Reads one line (terminated by '\n') from @var{port} and returns the line
as a string.  The last character '\n' is removed from the string. If
'\n' is immediately preceded by \, both \ and the '\n' is ignored.  If
there is no more line to be read, end of file object is returned.
If @var{port} is omitted, it defaults to the current input port.

@example
$ cat text
Hello, world!
Hello, another world!
$ ksm
> (define in (open-input-file "text"))
> (readline in)
        => "Hello, world!"
> (readline in)
        => "Hello, another world!"
> (close-input-port in)
@end example

@source{base/readline.c}
@use{none}
@end defun

@c ****************** Output *******************
@node Std-Output, Std-System-Interface, Std-Input, Standard Package
@section Output

@defun write @var{obj}
@defunx write @var{obj} @var{port}
Writes a written representation of @var{obj} to the given
@var{port}. Strings that appear in the written representation are
enclosed in doublequotes, and within those strings backslash and
doublequote characters are escaped by backslashes. Character objects are
written using the @code{#\} notation. @code{write} returns an
unspecified value. The @var{port} argument may be omitted, in which case
it defaults to the value returned by @code{current-input-port}.
@end defun

@defun display @var{obj}
@defunx display @var{obj} @var{port}
Writes a representation of @var{obj} to the given @var{port}. Strings
that appear in the written representation are not enclosed in
doublequotes, and no characters are escaped within those
strings. Character objects appear in the representation as if written by
@code{write-char} instead of @code{write}. @code{display} returns an
unsepcified value. The @var{port} argument may be omitted, in which case
it defaults to the value returned by @code{current-output-port}.
@end defun

@defun newline
@defunx newline @var{port}
Writes an end of line to @var{port}.  Returns an unspecified
value. The @var{port} argument may be omitted, in which case it defaults
to the value returned by @code{current-input-port}.
@end defun

@defun write-char @var{char}
@defunx write-char @var{char} @var{port}
Writes the character @var{char} to the given @var{port} and returns an
unspecified value. The @var{port} argument may be omitted, in which case
it defaults to the value returned by @code{current-output-port}.
@end defun

@defun flush-output-port [@var{port}]
Flushes @var{port}. If @var{port} is omitted, it defaults to the current
output port.
@end defun

@c ****************** System Interface *******************
@node Std-System-Interface,  , Std-Output, Standard Package
@section System Interface

@defun load @var{filename} [@var{encoding}]
@var{filename} should be a string naming an existing file containing
Scheme source code. The @code{load} procedure reads expressions from the 
file and evalutes them sequentially. The results of the expressions are
not automatically printed, in contrast to an interactive
session. @code{load} procedure does not affect the value returned by
@code{current-input-port} and @code{current-output-port}. @code{load}
returns an unspecified value. 

If @var{encoding} is supplied, it must be a string representing the
character-set encoding of the source file. If it is omitted, it defaults
to "UTF-8". While reading the source file, the encoding is automatically
converted to "UTF-8", which is the internal encoding in
KSM-Scheme. Acceptable encoding is available from @code{iconv --list}.

@example
(load "example.scm" "EUC-JP") ;; loads source file "example.scm"
                              ;; that is encoded in EUC-JP
@end example
@end defun

@defun load-file-name
Returns a string that represents the file name nder which current Scheme
source file is loaded.

@example
$ cat src.scm
(write (load-file-name))
(newline)
$ ksm
> (load "src.scm")
"src.scm"
@end example

@source{nterp/ext.c}
@use{none}
@end defun

@defun transcript-on @var{filename}
@defunx transcript-off

These functions are not supported in KSM-Scheme. If called they do
nothing and return an unspecified value.

In Revised^5 Report of Scheme, these functions are described as below.

@var{filename} must be a string naming an output file to be created. The
effect of @code{transcript-on} is to open the named file for output, and
to cause a transcript of subsequent interaction between the user and the
Scheme system to be written to the file. The transcript is ended by a
call to @code{transcript-off}, which closes the transcript file. Only
one transcript may be in progress at any time, though some
implementations may relax this restriction. The values returned by
these procedures are unspecified.
@end defun

@c ****************** Base Package ****************
@node Base Package, C Package, Standard Package, Top
@chapter Base Package

@menu
* List: Base-List.
* Use: Base-Use.
* Command Line Processing: Base-CmdLine.
* Private Variable: Base-Private.
* Queue: Base-Queue.
* Error Handling: Base-Error.
* Exit: Base-Exit.
* Hash Table: Base-Hashtab.
* Logical Operator: Base-Logical.
* Path: Base-Path.
* Dynamic Linking: Base-Shared.
* Signal: Base-Signal.
* Schedule: Base-Schedule.
* Case Sensitivity: Base-Case.
@end menu

@c **************** List *****************
@node Base-List, Base-Use, Base Package, Base Package
@section List
@defun first @var{list}
@defunx second @var{list}
@defunx third @var{list}
@defunx fourth @var{list}
@defunx fifth @var{list}
@defunx sixth @var{list}
@defunx seventh @var{list}
@defunx eighth @var{list}
@defunx ninth @var{list}
@defunx tenth @var{list}
These functions are equivalent to @code{(list-ref @var{list} 0)},
... @code{(list-ref @var{list} 9)}, respectively.

@example
(first '(1 2 3 4 5))     ==> 1
(third '(1 2 3 4 5))     ==> 3
(ninth '(1 2 3 4 5))     ==> #<error>
@end example
@end defun

@c ***************** Use *******************
@node Base-Use, Base-CmdLine, Base-List, Base Package
@section Use
@defun use @var{symbol}
Loads the source file that has been installed by the name of
@var{symbol} using @code{(use-install symbol)}.  If the source file has
been already loaded by a previous @code{(use @var{symbol})}, the file is
not loaded again. If there is no such a file associated with
@var{symbol}, an error is raised. Returns an unspecified value.

@source{init.scm}
@use{none}
@end defun

@defun use-install @var{symbol} @var{path}
Installs @var{path} of source file by the name of @var{symbol}. The
source file can be later loaded by @code{(use @var{symbol})}. Returns an
unspecified value.

@example
(use-install 'clang (path-append (ksm-directory) "clang/init.scm"))
@end example

@source{init.scm}
@use{none}
@end defun

@c **************** Command Line Processing **************
@node Base-CmdLine, Base-Private, Base-Use, Base Package
@section Command Line Processing

@defun cmdline-args [@var{optstring} @var{optfun}]

Returns a list of command line arguments (first argument is the program
name).  If @var{optstring} and @var{optfun} are supplied, options are
parsed with getopt (3) with the @var{opstring}, and for each optional
argument @var{optfun} is called with two arguments. The first argument
is the option character itself and the second argument is the supplied
option argument (if option argument is not supplied the second argument
defaults to #f).

In an interactive session, @code{cmdline-args} returns a list whose only
argument is the interpreter name.

@example
$ ksm
> (cmdline-args)
(ksm)
@end example

Following is an example when KSM-Scheme is invoked with a Scheme
program source.

@example
$ cat prog.scm
(display (cmdline-args))
(newline)
$ ksm prog.scm a b c
(prog.scm a b c)
@end example

The above example shows that the first element in the list returned by
@code{cmdline-args} is the name of the Scheme program (prog.scm),
instead of the interpreter name (ksm). It also shows that command line
arguments following the Scheme program name (a b c) consitute the
remaining elements in the list returned by @code{cmdline-args}.

@example
$ cat prog.scm
(display
  (cmdline-args
    "ab:c::d"
    (lambda (opt arg)
      (display "OPTION: ")
      (display opt) (display " ")
      (display arg) (newline))))
(newline)
$ ksm prog.scm -a -b ppp -c -d xyz pqr
OPTION: a #f
OPTION: b ppp
OPTION: c #f
OPTION: d #f
(prog.scm xyz pqr)
@end example

The above example illustrates the usage of @var{optstring}.
@var{optstring} is a string containing the legitimate option
characters. If such a character is followed by a colon (as in "b:"), the
option requires an argument. Two colons (as in "c::") indicates that an
option takes an optional argument.

By default, @code{cmdline-args} (more specifically, @code{getopt()} in C
library) permutes the commanline arguments as it scans, so that
eventually all the non-options are at the end. This behavior can be
overridden by placing @code{+} or @code{-} as the first character in
@var{optstring}. If @code{+} is the first character, then arguments are
not permuted and option processing stops as soon as a non-option argument
is encountered, as below.

@example 
$ cat prog.scm
(display
  (cmdline-args
    "+abc"
    (lambda (opt arg)
      (display "OPTION: ")
      (display opt) (display " ")
      (display arg) (newline))))
(newline)
$ ksm prog.scm -a xyz -b -c
OPTION: a #f
(prog.scm xyz -b -c)
@end example

If @code{-} is the first character, then arguments are not permuted and
each non-option argument is handled as if it were the argument of an
option with character code 1 (#\U@{0001@}). 

@example
$ cat prog.scm
(display
  (cmdline-args
    "-abc"
    (lambda (opt arg)
      (display "OPTION: ")
      (display opt) (display " ")
      (display arg) (newline))))
(newline)
$ ksm prog.scm -a xyz -b -c
OPTION: a #f
OPTION: #\U@{0001@} xyz
OPTION: b #f
OPTION: c #f
(prog.scm)
@end example

The special argument @code{--} forces an end of option-scanning
regardless of the scanning mode.

@code{cmdline-args} can be used in an interpreter file.

@example
$ cat prog
#!/usr/local/bin/ksm
(display
  (cmdline-args
    "abc"
    (lambda (opt arg)
      (display "OPTION: ")
      (display opt) (display " ")
      (display arg) (newline))))
(newline)
$ prog -a -b -c xyz
OPTION: a #f
OPTION: b #f
OPTION: c #f
(prog xyz)
@end example

@source{base/getopt.c}
@use{none}
@end defun

@c ******************* Private ****************
@node Base-Private, Base-Queue, Base-CmdLine, Base Package
@section Private Variable
@defspec define-private @var{symbol} @var{val}
@defspecx define-private (@var{symbol} @var{para} ...) @var{body} ...)

@code{define-private} is the same with @code{define} except that
@code{define-private} allocates or sets values of a variable in an
environment private to the source file. Such a variable can be directly
accessible only from expressions written in the same file. This behavior
is analogous to a @emph{static} global variable in C
language. @code{define-private} returns an unspecified value.

@example
$ cat a.scm
(define-private secret 123)
(define (a) secret)
$ ksm
> (load "a.scm")
> (a)
123
> secret
#<error>   ;; no such variable: secret
> (define-private secret 321)
> (a)
123        ;; accessing `secret' in "a.scm", indirectly
> secret
321        ;; accessing `secret' in the interactive environment
@end example

@source{base/base.c}
@use{none}
@end defspec

@defspec set-private! @var{symbol} @var{val}

Updates the value bound to the symbol spcified by @var{symbol} to
@var{val} in the environment private to the source file.  If there is no
such a symbol in the private environment, it raises an error. Therefore,
@code{set-private!} ensures that it does not inadvertently change the
value of a symbol defined in the global environment that is accessible
from any source file.

@example
$ cat a.scm
(define secret 123)
(define (a) secret)
$ ksm
> (load "a.scm")
> (a) 
123
> secret
123       ;; `secret' in "a.scm"
> (set-private! secret 321)
#<error>  ;; no such variable in the private environment
> (define-private secret 321)
> (a) 
123       ;; `secret' in "a.scm"
> secret 
321       ;; `secret' in the private environment
> (set-private! secret 4321) 
> secret  ;; `secret' in the private environment
4321
> (a)     ;; `secret' in "a.scm"
123

@source{base/base.c}
@use{none}
@end example
@end defspec

@c ****************** Queue ******************
@node Base-Queue, Base-Error, Base-Private, Base Package
@section Queue
It is often necessary to append an element at the tail of a list. With
the present implementation, this manipulation requires a computational
time that is proportional to the list length. @emph{Queue} object has
been introduced to accomplish such a manipulation in a constant time
regardles of the list length. Typical usage of queue is as follows.

@example
(define q (make-queue))
(enqueue! q 'one)
(enqueue! q 'two)
(enqueue! q 'three)
(queue-content q)     ==> (one two three) 
@end example

@defun make-queue
Returns an empty queue.

@source{base/queue.c}
@use{none}
@end defun

@defun enqueue! @var{queue} @var{obj}
Appends @var{obj} at the end of the @var{queue}. Returns an unspecified
value.

@source{base/queue.c}
@use{none}
@end defun

@defun queue-content @var{queue}
Returns the content of @var{queue} (a proper list).

@source{base/queue.c}
@use{none}
@end defun

@defun queue? @var{obj}
Returns @code{#t} if @var{obj} is a queue, otherwise returns @code{#f}.

@example
(define q (make-queue))
(enqueue! q 'apple)
(queue? q)          ==> #t
@end example

@source{base/queue.c}
@use{none}
@end defun

@defun dequeue! @var{queue}
Removes the first element from @var{queue}. Returns the removed element
(which had been the first element before @code{dequeue!} is called).

@example
(define queue (make-queue))
(enqueue! queue 'red)
(enqueue! queue 'yellow)
(queue-content queue)   ==> (red yellow)
(dequeue! queue)        ==> red
(queue-content queue)   ==> (yellow)
(dequeue! queue)        ==> yellow
(queue-content queue)   ==> ()
@end example

@source{base/queue.c}
@use{none}
@end defun

@defun queue-empty? @var{queue}
Returns @code{#t} if the content of @var{queue} is empty, otherwise
returns @code{#f}.

@example
(define q (make-queue))
(queue-empty? q)         ==> #t
(enqueue! q 'red)
(queue-empty? q)         ==> #f
@end example

@source{base/queue.c}
@use{none}
@end defun

@c ****************** Error *******************
@node Base-Error, Base-Exit, Base-Queue, Base Package
@section Error Handling

@defun error @var{string}
Prints @var{string} to the standard error and end the program
execution.  

@source{interp/ext.c}
@use{none}
@end defun

@defun fatal @var{string}
Prints @var{string} to the standard error and end the program
execution. Currently, effects of @code{error} and @code{fatal} are
equivalent. 

@source{interp/ext.c}
@use{none}
@end defun

@c ****************** Exit *********************
@node Base-Exit, Base-Hashtab, Base-Error, Base Package
@section Exit

@defun exit [@var{code}]
Exits the program with return code of @code{code}. If @code{code} is
omitted, it defaults to 0.

@source{base/base.c}
@use{none}
@end defun

@c ***************** Hash Table *****************
@node Base-Hashtab, Base-Logical, Base-Exit, Base Package
@section Hash Table
Hash table object is a table that stores objects attaching a name to
each object. One can lookup an object in the table by supplying its
name. Typical usage is as follows.

@example
(define tab (make-hashtab 100))
(hashtab-enter! tab 'John "New York")
(hashtab-enter! tab 'David "Dallas")
(hashtab-lookup tab 'John)     ==> "New York"
(hashtab-includes? tab 'Mary)  ==> #f
@end example

@defun make-hashtab @var{size}
Returns an empty hashtab. @var{size} indicates the size of the table. To be 
efficient, @var{size} is recommended to be larger than the expected
number of elements in the table. However, this is not a strictly
required condition. One can specify any positive value for @var{size},
and whatever the value of @var{size} is the table can store any number
of entries.

@source{base/hashtab.c}
@use{none}
@end defun

@defun hashtab? @var{obj}
Returns @code{#t} if @var{obj} is a hash table, otherwise returns
@code{#f}.

@source{base/hashtab.c}
@use{none}
@end defun

@defun hashtab-enter! @var{hashtab} @var{symbol} @var{value}
Enters a new entry in @var{hashtab}. The name of the entry is
@var{symbol} and its value is @var{value}.  If there is already an entry
with the same name, the entry is updated with @var{value}.
Returns an unspecified value.

@source{base/hashtab.c}
@use{none}
@end defun

@defun hashtab-lookup @var{hashtab} @var{symbol}
Returns the value of an entry, in @var{hashtab}, whose name is
equivalent to @var{symbol}.  If there is no such entry, it raises an
error.

@source{base/hashtab.c}
@use{none}
@end defun

@defun hashtab-includes? @var{hashtab} @var{symbol}
Returns @code{#t} if @var{hashtab} includes an entry whose name is
equivalent to @var{symbol}, otherwise returns @code{#f}.

@source{base/hashtab.c}
@use{none}
@end defun

@defun hashtab-update! @var{hashtab} @var{symbol} @var{value}
Updates the value of the entry, in @var{hashtab}, whose name is
equivalent to @var{symbol} to @var{value}.  If there is no such entry,
it raises an error. Returns an unspecified value.

@example
(define tab (make-hashtab 100))
(hashtab-enter! tab 'name 'Alice)
(hashtab-lookup tab 'name)          ==> Alice
(hashtab-update! tab 'name 'Bob)
(hashtab-lookup tab 'name)          ==> Bob
(hashtab-update! tab 'gender 'male) ==> #<error>
@end example

@source{base/hashtab.c}
@use{none}
@end defun

@c ***************** Logical *******************
@node Base-Logical, Base-Path, Base-Hashtab, Base Package
@section Logical Operator
@defun logical-and @var{arg} ...
Returns logical-and of @var{args} (that is, @var{arg1} & @var{arg2} &
... in C).

(logical-and 7 6) ==> 6

@source{base/logic.c}
@use{none}
NOTE: Currently, @var{args} are limited to 32-bit signed integers.
@end defun

@defun logical-or @var{arg} ...
Returns logical-or of @var{args} (that is, @var{arg1} | @var{arg2} |
... in C).

@source{base/logic.c}
@use{none}
NOTE: Currently, @var{args} are limited to 32-bit signed integers.
@end defun

@defun logical-xor @var{x} @var{y}
Returns exclusive-or of @var{x} and @var{y} (that is, @var{x}^@var{y} in
C).

@defun logical-lshift @var{expr} @var{n}
Returns the value of @var{expr} shifted to the left by @var{n}.

@example
(logical-lshift 1 2)  ==> 4
@end example
@end defun

@defun logical-rshift @var{expr} @var{n}
Returns the value of @var{expr} shifted to the left by @var{n}.

@example
(logical-rshift 1 2)  ==> 4
@end example
@end defun

@source{base/logic.c}
@use{none}
NOTE: Currently, @var{x} and @var{y} are limited to 32-bit integers.
@end defun

@defun logical-complement @var{arg}
Returns one's complement of @var{arg} (that is, ~@var{arg} in C).

@source{base/logic.c}
@use{none}
NOTE: Currently, @var{arg} is limited to 32-bit integer.
@end defun

@c ***************** Path ******************
@node Base-Path, Base-Shared, Base-Logical, Base Package
@section Path
@defun ksm-directory
Returns a string that represents the path-name of the KSM-Scheme home
directory.  KSM-Scheme home directory is determined as the parent
directory of the directory that contains the KSM-Scheme interpreter.
For example, if the interpreter is
@example
/usr/local/ksm/ksm-0.3.0/interp/ksm-0.3.0
@end example
KSM-Scheme home directory is
@example
/usr/local/ksm/ksm-0.3.0
@end example

@example
(ksm-directory)   ==> /usr/local/ksm/ksm-0.3.0  ;; example
@end example

@source{interp/ext.c}
@use{none}
@end defun

@defun path-append @var{node-name} @var{node-name} ...
Returns a string that concatenates all node-name's with inserting '/' 
between them.

@example
(path-append "/home/hangil" "src/ksm" "interp")
  ==> "/home/hangil/src/ksm/interp"
(path-append (ksm-directory) "base")
  ==> "/home/hangil/src/ksm/base"
@end example

@source{interp/path.c}
@use{none}
@end defun

@defun path-directory-part @var{path-name}
Returns a string that represents the directory part of the path-name.

@example
(path-directory-part "/home/hangil/src/ksm")
  ==> "/home/hangil/src"
(path-directory-part "src.scm")
  ==> "."
@end example

@source{interp/path.c}
@use{none}
@end defun

@c ***************** Dynamic Linking ****************
@node Base-Shared, Base-Signal, Base-Path, Base Package
@section Dynamic Linking
@defun load-shared @var{lib-path} [@var{init-fun}]
Loads shared library @var{lib-path}. If @var{init-fun} is supplied, it
also calls the C function named @var{init-fun} with no argument.
Returns an unspecified value.

If @var{lib-path} does not include @code{/}, the shared library with
that name is searched in default directories used by @code{ld.so}.

@example
(load-shared "./libservice.so" "init_service")
  ;; loads the shared library "libservice.so" present 
  ;; in the current directory and calls the C function 
  ;; "init_service" which should be decalred as 
  ;; "void init_service(void);" in C source.
@end example

@source{interp/ext.c}
@use{none}
@end defun

@c **************** Signal *****************
@node Base-Signal, Base-Schedule, Base-Shared, Base Package
@section Signal Handling
@defvar  @@SIGHUP
@defvarx @@SIGINT
@defvarx @@SIGQUIT
@defvarx @@SIGILL
@defvarx @@SIGTRAP
@defvarx @@SIGABRT
@defvarx @@SIGIOT
@defvarx @@SIGBUS
@defvarx @@SIGFPE
@defvarx @@SIGKILL
@defvarx @@SIGUSR1
@defvarx @@SIGSEGV
@defvarx @@SIGUSR2
@defvarx @@SIGPIPE
@defvarx @@SIGALRM
@defvarx @@SIGTERM
@defvarx @@SIGSTKFLT
@defvarx @@SIGCLD
@defvarx @@SIGCHLD
@defvarx @@SIGCONT
@defvarx @@SIGSTOP
@defvarx @@SIGTSTP
@defvarx @@SIGTTIN
@defvarx @@SIGTTOU
@defvarx @@SIGURG
@defvarx @@SIGXCPU
@defvarx @@SIGXFSZ
@defvarx @@SIGVTALRM
@defvarx @@SIGPROF
@defvarx @@SIGWINCH
@defvarx @@SIGPOLL
@defvarx @@SIGIO
@defvarx @@SIGPWR
@defvarx @@SIGUNUSED
@end defvar

These variables are signal numbers as defined in @code{signum.h}. Short
descriptions of their meanings are as follows (excerpted from
@code{signum.h}).

@multitable @columnfractions 0.2 0.1 0.7
@item @@SIGHUP    @tab 1  @tab Hangup (POSIX).  
@item @@SIGINT    @tab 2  @tab Interrupt (ANSI).  
@item @@SIGQUIT   @tab 3  @tab Quit (POSIX).  
@item @@SIGILL    @tab 4  @tab Illegal instruction (ANSI).  
@item @@SIGTRAP   @tab 5  @tab Trace trap (POSIX).  
@item @@SIGABRT   @tab 6  @tab Abort (ANSI).  
@item @@SIGIOT    @tab 6  @tab IOT trap (4.2 BSD).  
@item @@SIGBUS    @tab 7  @tab BUS error (4.2 BSD).  
@item @@SIGFPE    @tab 8  @tab Floating-point exception (ANSI). 
@item @@SIGKILL   @tab 9  @tab Kill, unblockable (POSIX).  
@item @@SIGUSR1   @tab 10 @tab User-defined signal 1 (POSIX).  
@item @@SIGSEGV   @tab 11 @tab Segmentation violation (ANSI).  
@item @@SIGUSR2   @tab 12 @tab User-defined signal 2 (POSIX).  
@item @@SIGPIPE   @tab 13 @tab Broken pipe (POSIX).  
@item @@SIGALRM   @tab 14 @tab Alarm clock (POSIX).  
@item @@SIGTERM   @tab 15 @tab Termination (ANSI).  
@item @@SIGSTKFLT @tab 16 @tab Stack fault.  
@item @@SIGCLD    @tab 17 @tab Same as SIGCHLD (System V).  
@item @@SIGCHLD   @tab 17 @tab Child status has changed (POSIX). 
@item @@SIGCONT   @tab 18 @tab Continue (POSIX).  
@item @@SIGSTOP   @tab 19 @tab Stop, unblockable (POSIX).  
@item @@SIGTSTP   @tab 20 @tab Keyboard stop (POSIX).  
@item @@SIGTTIN   @tab 21 @tab Background read from tty (POSIX).  
@item @@SIGTTOU   @tab 22 @tab Background write to tty (POSIX).  
@item @@SIGURG    @tab 23 @tab Urgent condition on socket (4.2 BSD).  
@item @@SIGXCPU   @tab 24 @tab CPU limit exceeded (4.2 BSD).  
@item @@SIGXFSZ   @tab 25 @tab File size limit exceeded (4.2 BSD).  
@item @@SIGVTALRM @tab 26 @tab Virtual alarm clock (4.2 BSD).  
@item @@SIGPROF   @tab 27 @tab Profiling alarm clock (4.2 BSD).  
@item @@SIGWINCH  @tab 28 @tab Window size change (4.3 BSD, Sun).  
@item @@SIGPOLL   @tab 29 @tab Pollable event occurred (System V).  
@item @@SIGIO     @tab 29 @tab I/O now possible (4.2 BSD).  
@item @@SIGPWR    @tab 30 @tab Power failure restart (System V).  
@item @@SIGUNUSED @tab 31
@end multitable

@defun make-sigset
Returns an empty sigset, which is a Scheme object that represents
@code{sigset_t} in C language.
@end defun

@defun sigset? @var{obj}
Returns @code{#t} if @var{obj} is a sigset object, otherwise returns
@code{#f}.
@end defun

@defun sigemptyset @var{sigset}
Excludes all of the defined signals from @var{sigset}. @var{sigset}
should be a sigset object. Returns an unspecified value.
@end defun

@defun sigfillset @var{sigset}
Adds all of the defined signals in @var{sigset}. @var{sigset}
should be a sigset object. Returns an unspecified value.
@end defun

@defun sigaddset @var{sigset} @var{signum}
Adds the signal @var{signum} in @var{sigset}. @var{sigset} should be a
sigset object. @var{sigset} should be an integer. Returns an unspecified
value.
@end defun

@defun sigdelset @var{sigset} @var{signum}
Deletes the signal @var{signum} from @var{sigset}. @var{sigset} should be a
sigset object. @var{sigset} should be an integer. Returns an unspecified
value.
@end defun

@defun sigismember? @var{sigset} @var{signum}
Returns @code{#t} if the signal @var{signum} is included in
@var{sigset}, otherwise returns @code{#f}. @var{sigset} should be a
sigset object. @var{sigset} should be an integer.
@end defun

@defvar  @@SIG_BLOCK
@defvarx @@SIG_UNBLOCK
@defvarx @@SIG_SETMASK

These variables are from @code{signal.h}.
@end defvar

@c ***************** Schedule ***************
@node Base-Schedule, Base-Case, Base-Signal, Base Package
@section Schedule

@defvar @@SCHED_RR
@defvarx @@SCHED_FIFO
@defvarx @@SCHED_OTHER
These values are from @code{sched.h}.
@end defvar

@c ***************** Case Sensitivity *****************
@node Base-Case,  , Base-Schedule, Base Package
@section Case Sensitivity
@defun set-read-case-sensitivitiy @var{bool}
Sets the case-sensitivity of Scheme reader. If @var{bool} is #t, symbol
names are read with preserving the case-sensitivity as in C (default
behavior). Otherwise, symbol names are read with ignoring the
case-sensitivity. Returns an unspecified value.

@example
(eq? 'abc 'ABC) ==> #f ;; KSM-Scheme is case sensitive by default
(set-read-case-sensitivity #f)
(eq? 'abc 'ABC) ==> #t ;; This is in accord with Scheme Standard
(set-read-case-sensitivity #t)
(eq? 'abc 'ABC) ==> #f ;;
@end example

@source{base/base.c}
@use{none}
NOTE: The default behavior of KSM-Scheme (case-sensitive) is contrary to
the Scheme Standard. This decision in KSM-Scheme was made to be
convinient in interfacing with C.
@end defun

@c ****************** C Package ******************
@node C Package, Regex Package, Base Package, Top
@chapter C Package

C Package includes procedures and special forms that are used to
interface with C functions and variables.

Before using functions and variables in C package, following function
call should be made to dynamically load necessary library.

@example
(use 'clang)
@end example

@menu
* Type Represetation: C-Type.
* Functions and Special Forms: C-Fun.
@end menu

@c ***************** C Types *****************
@node C-Type, C-Fun, C Package, C Package
@section Type Representation
In order to interface with C functions/variables effectively, Scheme
language should be able to represent types of C language. In KSM-Scheme,
following rules of representation are used.

For simple types, there is a one-to-one relationship between C types and
Scheme symbols.

@multitable @columnfractions 0.3 0.7
@item <C type> @tab <Scheme representation>
@item int @tab int
@item signed int @tab signed-int
@item unsigned int @tab unsigned-int
@item char @tab char
@item signed char @tab signed-char
@item unsigned char @tab unsigned-char
@item short @tab short
@item signed short @tab signed-short
@item unsigned short @tab unsigned-short
@item long @tab long
@item signed long @tab signed-long
@item unsigned long @tab unsigned-long
@item double @tab double
@item float @tab float
@item void @tab void
@end multitable

A pointer type is represented by a list whose first element represents
the pointed type and second element is the symbol @code{*}.

@multitable @columnfractions 0.3 0.7
@item <C type> @tab <Scheme representation>
@item @var{type} * @tab (@var{type} *)
@end multitable

For example,
@example
int *    <==>  (int *)
char *   <==>  (char *)
char **  <==>  ((char *) *)
@end example

An array type is represented by a list whose first element represents
the type of the elements, second element is the symbol @code{[]}, and
the last element is the number of elements in the array.

@multitable @columnfractions 0.3 0.7
@item <C type> @tab <Scheme representation>
@item @var{type} @var{symbol}[@var{size}] @tab (@var{type} [] @var{size})
@end multitable

For example,
@example
int a[10]    <==> (int [] 10)
char *s[6]   <==> ((char *) [] 6)
char (*s)[6] <==> ((char [] 6) *)
@end example

Structures and unions are represented as lists with the following form.

@multitable @columnfractions 0.4 0.6
@item <C type> @tab <Scheme representation>
@item struct @var{struct-name}
@tab (struct @var{struct-name})
@item struct [@var{struct-name}] @{ @var{type} @var{name} [@var{bits}];
...@}
@tab (strcut [@var{struct-name}] ((@var{type} @var{name} [@var{bits}])
...))
@item union @var{union-name}
@tab (union @var{union-name})
@item union [@var{union-name}] @{ @var{type} @var{name} [@var{bits}];
...@}
@tab (union [@var{union-name}] ((@var{type} @var{name} [@var{bits}]) ...))
@end multitable

For example,
@example
struct point @{           (struct point
  int x;            <==>   (int x)
  int y; @};                (int y))

struct @{                 (struct
  char *name;       <==>   ((char *) name)
  int   id; @};             (int id))

struct @{                 (struct
  int x;                   (int x)
  int flag: 2;      <==>   (int flag 2)
  int y; @}                 (int y))

union @{                  (union
  int ival;                (int ival)
  double dval;      <==>   (double dval)
  void *pval; @}            ((void *) pval))
@end example

@c ***************** C Functions *****************
@node C-Fun,  , C-Type, C Package
@section Functions and Special Forms

@defspec clang:sym @var{type} @var{symbol}
@defspecx clang:sym @var{ret-type} (@var{symbol} @var{type} ...)
In the first form, @code{clang:sym} looks up a C variable whose name is
@var{symbol} then returns a C object that binds the address of the C
variable with @var{type}. In the second form, @code{clang:sym} looks up
a C function whose name is @var{symbol} and returns a corresponding C
object. The return type of the C function is specified by
@var{ret-type}, and types of arguments are specified by
@var{types}. @xref{C-Type, C type representation}, for details about C
type representation in KSM-Scheme.

@example
$ cat src.c
int a = 12;
double b;
char *c;
int get_a(void) @{ return a; @}
int iadd(int a, int b) @{ return a+b; @}
$ gcc -c -fPIC src.c
$ gcc -shared -o src.so src.o -lc
$ ksm
> (use 'clang)
> (load-shared "./src.so")
> (clang:sym int a)        ==> #<C-object>
> (clang:sym double b)     ==> #<C-object>
> (clang:sym (char *) c)   ==> #<C-object>
> (clang:sym int (get_a))  ==> #<C-object>
> (define a (clang:sym int a))
> (define f (clang:sym int (get_a)))
> (define iadd (clang:sym int (iadd int int)))
> a                        ==> 12
> (f)                      ==> 12
> (iadd 60 2)              ==> 62
@end example

C object returned by @code{clang:sym} can be used to set the value of
the C variable as follows.

@example
$ cat src.c
int a = 12;
int get_a(void) @{ return a; @}
$ gcc -c -fPIC src.c
$ gcc -shared -o src.so src.o -lc
$ ksm
> (use 'clang)
> (load-shared "./src.so")
> (clang:sym int a)        ==> #<C-object>
> (clang:sym int (get_a))  ==> #<C-object>
> (define a (clang:sym int a))
> (define f (clang:sym int (get_a)))
> a                        ==> 12
> (f)                      ==> 12
> (set! a 123)             ==> 123
> (f)                      ==> 123
@end example

@source{clang/clang.c}
@use{clang}
@end defspec

@defun clang:* @var{csym}
@var{csym} must be a C object whose type is a pointer. Returns the
object pointed by @var{csym}.

@example
$ cat src.c
int ival = 1;
int *ip = &ival;
int getval(void) @{ return ival; @}
$ gcc -c -fPIC src.c
$ gcc -shared -o src.so src.o -lc
$ ksm
> (use 'clang)
> (load-shared "./src.so")
> (define ip (clang:sym (int *) ip))
> (clang:* ip) ==> 1
@end example

@code{clang:*} can be used to set the value pointed by @var{cobject} as
follows.

@example
$ ksm
> (use 'clang)
> (load-shared "./src.so")
> (define f (clang:sym int (getval)))
> (f)                     ==> 1
> (define ip (clang:sym (int *) ip))
> (clang:* ip)            ==> 1
> (set! (clang:* ip) 12)
> (clang:* ip)            ==> 12
> (f)                     ==> 12
@end example

@source{clang/clang.c}
@use{clang}
@end defun

@defun clang:[] @var{csym} @var{index}
@var{csym} must be a C object whose type is array or
pointer. @var{index} should be an integer.  Returns the value of
@var{index}-th element of array @var{csym}.  "cobject" must have an
array type.

@example
$ cat src.c
int a[3] = @{ 1, 2, 3 @};
$ gcc -c -fPIC src.c
$ gcc -shared -o src.so src.o -lc
$ ksm
> (use 'clang)
> (load-shared "./src.so")
> (define a (clang:sym (int [] 3) a))
> (clang:[] a 0) ==> 1
> (clang:[] a 1) ==> 2
> (clang:[] a 2) ==> 3
@end example

@code{clang:[]} can be used to set the value of array element as follows.

@example
$ cat src.c
int a[3] = @{ 1, 2, 3 @};
int f(void) @{ return a[0]; @}
$ gcc -c -fPIC src.c
$ gcc -shared -o src.so src.o -lc
$ ksm
> (define a (clang:sym (int [] 3) a))
> (define f (clang:sym int (f)))
> (f)            ==> 1
> (clang:[] a 0) ==> 1
> (set! (clang:[] a 0) 12)
> (clang:[] a 0) ==> 12
> (f)            ==> 12
@end example

@source{clang/clang.c}
@use{clang}
@end defun

@defun clang:. @var{csym} @var{field}
@var{csym} must be a C object whose type is struct or union.  Returns
the value of @var{field} of @var{csym}. If there is no such @var{field},
an error is raised.

@example
$ car src_a.so
struct point @{
  int x;
  int y;
@} pp = @{ 1, 2 @};
$ gcc -c -fPIC src_a.c
$ gcc -shared -o src_a.so src_a.o -lc
$ ksm
> (use 'clang)
> (load-shared "./src_a.so")
> (define pp (clang:sym (struct pp (int x) (int y)) pp))
> (clang:. pp 'x) ==> 1
> (clang:. pp 'y) ==> 2

$ car src_b.c
struct cpoint @{
  int x;
  int colored: 1;
  int y;
@} cp = @{ 10, 1, 20 @};
$ gcc -c -fPIC src_b.c
$ gcc -shared -o src_b.so src_b.o -lc
$ ksm
> (use 'clang)
> (load-shared "./src_b.so")
> (define cp 
    (clang:sym (struct cp (int x) 
                          (int colored 1) 
                          (int y)) 
                  cp))
> (clang:. pp 'x)        ==> 10
> (clang:. pp 'colored)  ==> -1
> (clang:. pp 'y)        ==> 20
@end example

@code{clang:.} can be used to set the value of @var{field} in
@var{csym}, as follows.

@example
$ car src_a.so
struct point @{
  int x;
  int y;
@} pp = @{ 1, 2 @};
int get_x(void) @{ return pp.x; @}
$ gcc -c -fPIC src_a.c
$ gcc -shared -o src_a.so src_a.o -lc
$ ksm
> (use 'clang)
> (load-shared "./src_a.so")
> (define pp (clang:sym (struct pp (int x) (int y)) pp))
> (define get-x (clang:sym int (get_x)))
> (get-x)         ==> 1
> (set! (clang:. pp 'x) 100)
> (get-x)         ==> 100

$ car src_b.c
struct cpoint @{
  int x;
  int colored: 1;
  int y;
@} cp = @{ 10, 1, 20 @};
int get_colored(void) @{ return cp.colored; @}
$ gcc -c -fPIC src_b.c
$ gcc -shared -o src_b.so src_b.o -lc
$ ksm
> (use 'clang)
> (load-shared "./src_b.so")
> (define cp (clang:sym (struct cp (int x) 
                                   (int colored 1) 
                                   (int y)) 
                          cp))
> (define get-colored (clang:sym int (get_colored)))
> (get-colored)          ==> -1
> (set! (clang:. cp 'colored) 0)
> (get-colored)          ==> 0
@end example

@source{clang/clang.c}
@use{clang}
@end defun

@defun clang:-> @var{csym} @var{field}
@var{csym} must be a C object whose type is a pointer to a structure.
Returns the value of @var{field} in the structure pointed by @var{csym}.
If there is no such a field, an error is raised.

@example
$ cat src.c
struct point @{
  int x;
  int y;
@} pp = @{ 1, 2 @};
$ gcc -c -fPIC src.c
$ gcc -shared -o src.so src.o -lc
$ ksm
> (use 'clang)
> (load-shared "./src.so")
> (define p
    (clang:& (clang:sym (struct point (int x) (int y)) pp)))
> (clang:-> p 'x) ==> 1
> (clang:-> p 'y) ==> 2
@end example

@example
$ cat src.c
struct point @{
  int x;
  int y;
@} pp = @{ 1, 2 @};
int get_x(void) @{ return pp.x; @}
$ gcc -c -fPIC src.c
$ gcc -shared -o src.so src.o -lc
$ ksm
> (use 'clang)
> (load-shared "./src.so")
> (define p
    (clang:& (clang:sym (struct point (int x) (int y)) pp)))
> (define f (clang:sym int (get_x)))
> (f)                ==> 1
> (set! (clang:-> p 'x) 100)
> (f)                ==> 100
@end example

@source{clang/clang.c}
@use{clang}
@end defun

@defun clang:& @var{csym}
@var{csym} must be a C object.  Returns a C object corresponding to the
address @var{csym}.

@example
$ cat src.c
int a = 12;
int f(void) @{ return a; @}
$ gcc -c -fPIC src.c
$ gcc -shared -o src.so src.o -lc
$ ksm
> (use 'clang)
> (load-shared "./src.so")
> (define a (clang:sym int a))
> (define ip (clang:& a))
> (clang:* ip)          ==> 12
> (set! (clang:* ip) 123)
> a                     ==> 123
> ((clang:sym int (f))) ==> 123
@end example

@source{clang/clang.c}
@use{clang}
@end defun

@defun clang:get-value @var{csym}
@var{csym} must be a C object.  Converts @var{csym} to standard Scheme
object according to the type of @var{csym}. If such a conversion is not
possible, @var{csym} itself is returned.

@example
$ cat src.c
int a = 1; 
char *f(void) @{ return "hello"; @}
$ gcc -c -fPIC src.c
$ gcc -shared -o src.so src.o -lc
$ ksm
> (use 'clang)
> (load-shared "./src.so")
> (define a (clang:sym int a))
> (define f (clang:sym (char *) (f)))
> a                        ==> 1
> (number? a)              ==> #f
> (number? (get-value a))  ==> #t
> (f)                      ==> #<csym>
> (get-value (f))          ==> "hello"
@end example

@source{clang/clang.c}
@use{clang}

NOTE: Currently, C object whose type is @code{int}, @code{signed int},
@code{double}, or @code{char *} is converted a standard Scheme object.
@end defun

@defspec clang:struct @var{struct-name}
@defspecx clang:struct [@var{struct-name}] (@var{type} @var{field-name}) ...)
@defspecx clang:union @var{union-name}
@defspecx clang:union [@var{union-name}] (@var{type} @var{field-name}) ...)
Declares a structure/union corresponding to a C structure/union. Returns
an unspecified value. Syntax of these forms are the same with the syntax
of Scheme representation of C structure/union, except that the first
@code{struct}/@code{union} element in the list is replaced by
@code{clang:struct}/@code{clang:union}. @xref{C-Type, C type
representation}, for details about C type representation in KSM-Scheme.

@example
(clang:struct point (int x) (int y))
(clang:sizeof (struct point))    ==> 8
@end example

It is an error to declare a different kind of structure/union under the
name of the same @var{struct-name}.

@example
$ ksm
> (clang:struct point (int x) (int y))
> (clang:struct point (double x) (double y)) ==> #<error>
> (clang:struct point (int x) (int y))   ;; This is OK.
> (clang:struct point (int p) (int q))       ==> #<error>
@end example

Structure/union declarations without field definitions are allowed
regardless whether field definitions are conducted elsewhere in the
source or not.

@example
$ ksm
> (clang:struct point)
> (clang:struct point (int x) (int y))  ;; This is OK.
$ ksm
> (clang:struct point (int x) (int y))
> (clang:struct)      ;; This is also OK.
@end example

@source{clang/clang.c}
@use{clang}
@end defspec   
@c *** clang:struct ***

@c *** clang:typedef ***
@defspec clang:typedef @var{type} @var{symbol}
@defspecx clang:typedef @var{type} (@var{symbol} @var{type} ...)
Associates @var{symbol} with @var{type}, equivalent to `typedef' in C.
Returns an unspecified value. @xref{C-Type, C type representation}, for
details about representation of C type in KSM-Scheme.

@example
(clang:typedef int Integer)
(clang:typedef (int *) int_ptr)
(clang:typedef double Real)
(clang:sizeof Integer)  ==> 4
(clang:sizeof int_ptr)  ==> 4
(clang:sizeof Real)     ==> 8
@end example

@source{clang/clang.c}
@use{clang}
@end defspec   
@c *** clang:typedef ***

@defspec clang:new @var{type}
@var{type} must be a Scheme object that represents a C type.  Allocates
a memory area (@code{malloc}-ed) with size of @var{type} and returns a C
object corresponding to the memory area. This memory area is not
automatically garbage collected, and it should be explicitly freed by
@code{clang:dispose}. For details of representation of C type, see
@code{clang:sym}.

@example
> (define a (clang:new int))
> (set! a 10)
> a ==> 10
> (clang:dispose a)
@end example

@source{clang/clang.c}
@use{clang}
@end defspec

@defun clang:dispose @var{csym}
@var{csym} must be a C object allocated by @code{clang:new}.  Frees the
memory allocated to @var{csym}. Returns an unspecified value.

@example
> (define a (clang:new int))
> (set! a 10)
> a                 ==> 10
> (clang:dispose a)
@end example

@source{clang/clang.c}
@use{clang}
@end defun

@defspec clang:sizeof @var{type}
@var{type} must be a Scheme object that represents a C type.  Returns
the byte-size of @var{type}. @xref{C-Type, C type representation}, for
details about C type representation in KSM-Scheme.

@example
(clang:sizeof int)    ==> 4
(clang:sizeof double) ==> 8
(clang:sizeof (struct (int x) (int y)))    ==> 8
(clang:sizeof (struct (int x) (double y))) ==> 16
(clang:sizeof (int *)) ==> 4
@end example

@source{clang/clang.c}
@use{clang}
@end defspec

@defspec clang:align @var{type}
@var{type} must be a Scheme object that represents a C type.  Returns
the byte-alignment of @var{type}. For details of representation of C
type, see @code{clang:sym}.

@example
(clang:align int)                         ==> 4
(clang:align double)                      ==> 8
(clang:align (struct (int x) (double y))) ==> 8
@end example

@source{clang/clang.c}
@use{clang}
@end defspec

@c ****************** Regex *******************
@node Regex Package, Thread Package, C Package, Top
@chapter Regular Expression Package
Procedures that handle regular expression support Unicode in the sense
that it handle characters as basic 16-bit logical units, and that it
supports case-insensitive match for all Unicode characters including
those beyong ASCII range.

Regular expression engine is based on the one developed by Henry
Spencer. We have modified the original source to support Unicode
characters.

Before using functions and variables in Regex Package, following
function call should be made to dynamically load necessary library.

@example
(use 'regex)
@end example

@menu
* Regular Expression: Regex-Regex.
* Procedures: Regex-Procs.
* Character Names: Regex-Cname.
@end menu

@c ***************** Regular Expression ***************
@node Regex-Regex, Regex-Procs, Regex Package, Regex Package
@section Regular Expression
Regular expressions, as defined in POSIX 1003.2, come in two forms:
modern regular expressions and obsolete regular expressions. Obsolete
regular expressions (roughly those of @code{ed}; 1003.2 @emph{basic}
regular expressions) mostly exist for backward compatibility in some old
programs. KSM-Scheme uses modern regular expressions (roughly those of
@code{egrep}; 1003.2 calls these @emph{extended} regular expressions)
with additional functionality of @emph{back references}.

A regular expression is one or more non-empty @emph{branches}, separated
by @code{|}. It matches anything that matches one of the branches.

@example
"one|two|three" ==> matches "one", "two", or "three"
@end example

A branch is one or more @emph{pieces}, concatenated. It matches a match
for the first, followed by a match for the second, etc.

A piece is an @emph{atom} possibly followed by a single @code{*},
@code{+}, @code{?}, or @emph{bound}. An atom followed by @code{*}
matches a sequence of 0 or more matches of the atom. An atom followed by
@code{+} matches a sequence of 1 or more matches of the atom. An atom
followed by @code{?} matches a sequence of 0 or 1 matches of the atom.

@example
"a*" ==> matches "", "a", "aa", "aaa", ...
"a+" ==> matches "a", "aa", "aaa", ...
"a?" ==> matches "" or "a"
@end example

A bound is @code{@{} followed by a decimal integer, possibly followed by
@code{,} possibly followed by another decimal integer, always followed
by @code{@}}. The integers must lie between 0 and 255 inclusive, and if
there are two of them, the first may not exceed the second. An atom
followed by a bound containing one integer @emph{i} and no comma matches
a sequence of exactly @emph{i} matches of the atom. An atom followed by
a bound containing one integer @emph{i} and a comma matches a sequence
of @emph{i} or more matches of the atom. An atom followed by a bound
containing two integers @emph{i} and @emph{j} matches a sequence of
@emph{i} through @emph{j} (inclusive) matches of the atom.

@example
"a@{3@}"   ==> matches "aaa"
"a@{3,@}"  ==> matches "aaa", "aaaa", "aaaaa", ...
"a@{3,4@}" ==> matches "aaa" or "aaaa"
@end example

An atom is a regular expression enclosed in @code{()} (matching a match
for the regular expression), an empty set of @code{()} (matching the
null string), a @emph{bracket expression} (see below), @code{.}
(matching any single character), @code{^} (matching the null string at
the beginning of a line), @code{$} (matching the null string at the end
of a line), a @emph{back reference} (see below), a @code{\} followed by
one of the characters @code{^.[$()|*+?@{\} (matching that character
taken as an ordinary character), a @code{\} followed by any other
character (matching that character taken as an ordinary character, as if
the @code{\} had not been present), or a single character with no other
significance (matching that character). A @code{@{} followed by a
character other than a digit is an ordinary character, no the beginning
of a bound. It is illegal to end a regular expression with @code{\}.

A bracket expression is a list of characters enclosed in @code{[]}. It
normally matches any single character from the list (but see below). If
the list begins with @code{^}, it matches any single character (but see
below) @emph{not} from the rest of the list. If two characters in the
list are separated by @code{-}, this is shorthand for the full
@emph{range} of characters between those two (inclusive),
e.g. @code{[0-9]} matches any decimal digit. It should be noted that
ordering of characters is equivalent to that of Unicode code values. It
is illegal for two ranges to share an endpoint, e.g. @code{a-c-e}.

@example
"[a-z]"  ==> matches small letter alphabets
"[^0-9]" ==> matches all characters except '0' through '9'
@end example

To include a literal @code{]} in the list, make it the first character
(following a possible @code{^}). To include a literal @code{-}, make it
the first or last character, or the second endpoint of a range. To use a
literal @code{-} as the first endpoint of a range, enclose it in
@code{[.} and @code{.]} to make it a character-name element (see
below). With the exception of these and some combinations using @code{[}
(see next paragraphs), all other special characters, including @code{\},
lose their special sigfinicance within a bracket expression.

@example
"[]]"       ==> matches ']'
"[^]]"      ==> matches characters except ']'
"[-]"       ==> matches '-'
"[^-a]"     ==> matches characters except '-' and 'a'
"[^]-~]"    ==> matches characters except '-' through '~'
"[a--]"     ==> matches characters from 'a' through '-'
"[abc-]"    ==> matches 'a', 'b', 'c', or '-'
"[[.-.]-~]" ==> matches characters from '-' through '~'
@end example

Within a bracket expression, a character-name element enclosed in
@code{[.} and @code{.]} stands for the character that is represented by
the name. For example, @code{[.backspace.]} stands for
@code{#\U@{0008@}}. For a list of acceptable names of characters, see
@ref{Regex-Cname}. 

Within a bracket expression, the name of a @emph{character class}
enclosed in @code{[:} and @code{:]} stands for the list of all
characters belonging to that class. Standard character class names are:

@multitable @columnfractions 0.1 0.2 0.2 0.2
@item @tab alnum @tab digit @tab punct
@item @tab alpha @tab graph @tab space
@item @tab blank @tab lower @tab upper
@item @tab cntrl @tab print @tab xdigit
@end multitable

These stand for the character classes defined in @code{ctype}(3). A
character class may not be used as an endpoint of a range.

There are two special cases of bracket expressions: the bracket
expression @code{[[:<:]]} and @code{[[:>:]]} match the null string at
the beginning and end of a word respectively. A word is defined as a
sequence of word characters which is neither preceded nor followed by
word characters. A word character is an @code{alnum} character (as
defined by @code{ctype}(3)) or an underscore.

In the event that a regular expression could match more than one
substring of a given string, the regular expression matches the one
starting earliest in the string. If the regular expression could match
more than one substring starting at that point, it matches the
longest. Subexpressions also match the longest possible substrings,
subject to the constraint that the whole match be as long as possible,
with subexpressions starting earlier in the regular expression taking
priority over ones starting later. Match lengths are measured in
characters. A null string is considered longer than no match at all.
For example, @code{bb*} matches the three middle characters of
@code{abbbc}, @code{(wee|week)(knights|nights)} matches all ten
characters of @code{weeknights}, when @code{(.*).*} is matched against
@code{abc} the prenthesized subexpression matches all three characters,
and when @code{(a*)*} is matched against @code{bc} both the whole
regular expression and the parenthesized subexpression match the null
string.

If case-independent matching is specified, the effect is much as if all
case distinctions had vanished from the alphabet. When an alphabetic
that exists in multiple cases appears as an ordinary character outside a
bracket expression, it is effectively transformed into a bracket
expression containing both cases, e.g. @code{x} becomes
@code{[xX]}. When it apperas inside a bracket expression, all case
counterparts of it are added to the bracket expression, so that (e.g.)
@code{[x]} becomes @code{[xX]} and @code{[^x]} becomes @code{[^xX]}.

A @emph{back reference} atom that is represented by a @code{\} followed
by a non-zero decimal digit @emph{d} matches the same sequence of
characters matched by the @emph{d}-th parenthesized subexpression
(numbering subexpressions by the positions of their opening parentheses,
left to right), so that (e.g.) @code{([bc])\1} matches @code{bb} or
@code{cc} but not @code{bc}.

NOTE: This description of regular expression is based on the
documentation included in the regular expression library of Henry
Spencer.

@c ****************** Regex Procedures ***************
@node Regex-Procs, Regex-Cname, Regex-Regex, Regex Package
@section Regex Procedures

@c *** regex:regcomp ***
@defun regex:regcomp @var{pattern} &key (ignore-case #f) (newline #f)
(no-special #f)

@var{pattern} should be a string that specify a regular expression.
Returns a regular expression object that is specified by @var{pattern}.

If @code{ignore-case} is not false, it specifies a matching that ignores
upper/lower case distinctions.  

If @code{newline} is not false, it specifies a newline-sensitive
matching. By default, newline is completely ordinary character with no
special meaning in either regular expressions or strings. With this
flag, @code{[^...]} bracket expressions and @code{.} never match
newline. @code{^} matches the empty string immediately after a
newline. @code{$} matches the empty string immediately before a
newline. 

If @code{no-special} is not false, it specifies a matching with meanings
of all special characters turned off. All characters are thus considered
ordinary, so the regular expression is a literal string.

This procedure supports for Unicode characters as basic 16-bit logical
units. Case-insensitive match supports for Unicode characters (beyond
ASCII characters).

@example
(define re (regex:regcomp "[a-z]+.scm"))
(regex:regexec re "abc.scm") ==> #t
(regex:regexec re "Abc.scm") ==> #f

(define re (regex:regcomp "[a-z]+.scm" :ignore-case #t))
(regex:regexec re "Abc.scm") ==> #t

(define re (regex:regcomp "[^0-9]+"))
(regex:regexec re "abcd\nefg") ==> #t
(regex:subexpr re 0)           ==> "abcd\nefg"
(define re (regex:regcomp "[^0-9]+") :newline)
(regex:regexec re "abcd\nefg") ==> #t
(regex:subexpr re 0)           ==> "abcd"

(define re (regex:regcomp ".+"))
(regex:regexec re "abcd\nefg") ==> #t
(regex:subexpr re 0)           ==> "abcd\nefg"
(define re (regex:regcomp ".+") :newline)
(regex:regexec re "abcd\nefg") ==> #t
(regex:subexpr re 0)           ==> "abcd"

(define re (regex:regcomp "^hello$"))
(regex:regexec re "aaa\nhello\nbbb")  ==> #f
(define re (regex:regcomp "^hello$" :newline))
(regex:regexec re "aaa\nhello\nbbb")  ==> #t

(define re (regex:regcomp ".+"))
(regex:regexec re "abcd")             ==> #f
(regex:regexec re ".+")               ==> #t
@end example

In KSM-Scheme, several escape sequences in a string are processes while
they are read from the program source. They are 

@example
"\""      ==> "  (a string composed of a doublequote character)
"\\"      ==> \
"\n"      ==> newline
"\r"      ==> carriage return
"\t"      ==> tab
"\U@{XXXX@} ==> character corresponding to Unicode 
              code value XXXX (hexadecimal)
@end example

Consequently, a string @code{"\n"} is converted to a string with one
character (newline character) while it is read, and @code{(regex:regcomp
"[\n]")} returns a regular expression object that matches a string
containing a newline character.

A backslash in a string followed by other characters loses its special
meaning and represents a backslash character by itself. Consequently,
@code{(regex:regcomp "\$")}, as well as @code{(regex:regcomp "\\$")},
returns a regular expression object that matches a string containing a
character '$'.

@source{regex/regex.c}
@use{regex}
@end defun
@c *** regex:regcomp ***

@c *** regex:regexec ***
@defun regex:regexec @var{regex} @var{string} &key (not-bol #f) (not-eol
#f))

Matches a regular expression object @var{regex} against @var{string},
and returns @code{#t} if matching succeeds or @code{#f} if matching
fails. 

If @code{not-bol} is not false, the first character of @var{string} is
not the beginning of a line, so the @code{^} anchor should not match
before it. This does not affect the behavior of newlines when @var{regex}
was created with @code{:newline #t}.

If @code{not-eol} is not false, termination of @var{string} does not end
a line, so the `$' anchor should not match before it. This does not
affect the behavior of newlines when @var{regex} was compiled with
@code{:newline #t}.

This procedure supports for Unicode characters as basic 16-bit logical
units. 

@example
(define re (regex:regcomp "ab+c"))
(regex:regexec re "abbbbbbbc")   ==> #t
(regex:regexec re "ac")          ==> #f

(define re (regex:regcomp "^hello"))
(regex:regexec re "hello")          ==> #t
(regex:regexec re "hello" :not-bol) ==> #f

(define re (regex:regcomp "hello$"))
(regex:regexec re "hello")          ==> #t
(regex:regexec re "hello" :not-eol) ==> #f
@end example

@source{regex/regex.c}
@use{regex}
@end defun
@c *** regex:regexec ***

@c *** regex:subexpr ***
@defun regex:subexpr @var{regex} @var{index}
Returns a string comprised of characters matched by the @var{index}-th
parenthesized subexpression in @var{regex}. @var{regex} must be a
regular expression object with which @code{regex:regexec} has been
successfully conducted.

@var{index} of 1 indicates the first subexpression, @var{index} of 2
indicates the second subexpression, and so on. @var{index} of 0
indicates the whole substring that had been matched with @var{regex}.

@example
(define re (regex:regcomp "(a+)(b+)"))
(regex:regexec re "aaabbccc")  ==> #t
(regex:subexpr re 0)           ==> "aaabb"
(regex:subexpr re 1)           ==> "aaa"
(regex:subexpr re 2)           ==> "bb"
@end example
@end defun
@c *** regex:subexpr ***


@c *** regex:split ***
@defun regex:split @var{regex} @var{string}

Splits @var{string} with delimiters that match @var{pattern}. Returns a
list comprising of the substrings. 

@example
(regex:split "abcdefg" (regex:regcomp "d")) 
                   ==> ("abc" "efg")
(regex:split "123k234h345" (regex:regcomp "[a-z]")) 
                   ==> ("123" "234" "345")
(regex:split "123abc234" (regex:regcomp "[a-z]+")) 
                   ==> ("123" "234")
@end example

@source{regex/regex.c}
@use{regex}
@end defun
@c *** regex:split ***

@c *** regex:replace ***
@defun regex:replace regex string generator &key (not-bol #f) (not-eol
#f) (count -1)

Returns a string which is created by replacing strings returned by
@var{generator} for subexpression that match @var{regex} in
@var{string}. @var{regex} should be a regular expression
object. @var{generator} should be a function that takes one argument, a
regular expression object, and returns a string.

@code{not-bol} and @code{not-eol} arguments have the same meanings as in
@code{regex:regexec}. 

@code{count} specifies the number of replacements to be made. If
@code{count} is -1, all matching subexpressions are replaced.

@example
(regex:replace (regex:regcomp ":")
               "abc:def:ghi"
               (lambda (re) " "))
  ==> "abc def ghi"

(regex:replace (regex:regcomp "([a-z])([a-z])")
               "123ab234cd345ef"
               (lambda (re)
                 (string-append (regex:subexpr re 2)
                                (regex:subexpr re 1))))
  ==> "123ba234dc345fe"

(regex:replace (regex:regcomp "([0-9]+)X([0-9]+)")
               "123X789A234X777B333X222" 
               (lambda (reg) 
                  (string-append 
                    (regex:subexpr reg 2) 
                    "X" 
                    (regex:subexpr reg 1))) 
               :count 2)
  ==> "789X123A777X234B333X222"
@end example
@end defun
@c *** regex:replace ***

@c ****************** Regex-Cname *****************
@node Regex-Cname,  , Regex-Procs, Regex Package
@section Character Names
@multitable @columnfractions 0.3 0.7
@item NUL @tab 	'\0' 
@item SOH @tab 	'\001' 
@item STX @tab 	'\002' 
@item ETX @tab 	'\003' 
@item EOT @tab 	'\004' 
@item ENQ @tab 	'\005' 
@item ACK @tab 	'\006' 
@item BEL @tab 	'\007' 
@item alert @tab 	'\007' 
@item BS @tab 		'\010' 
@item backspace @tab 	'\b' 
@item HT @tab 		'\011' 
@item tab @tab 		'\t' 
@item LF @tab 		'\012' 
@item newline @tab 	'\n' 
@item VT @tab 		'\013' 
@item vertical-tab @tab 	'\v' 
@item FF @tab 		'\014' 
@item form-feed @tab 	'\f' 
@item CR @tab 		'\015' 
@item carriage-return @tab 	'\r' 
@item SO @tab 	'\016' 
@item SI @tab 	'\017' 
@item DLE @tab 	'\020' 
@item DC1 @tab 	'\021' 
@item DC2 @tab 	'\022' 
@item DC3 @tab 	'\023' 
@item DC4 @tab 	'\024' 
@item NAK @tab 	'\025' 
@item SYN @tab 	'\026' 
@item ETB @tab 	'\027' 
@item CAN @tab 	'\030' 
@item EM @tab 	'\031' 
@item SUB @tab 	'\032' 
@item ESC @tab 	'\033' 
@item IS4 @tab 	'\034' 
@item FS @tab 	'\034' 
@item IS3 @tab 	'\035' 
@item GS @tab 	'\035' 
@item IS2 @tab 	'\036' 
@item RS @tab 	'\036' 
@item IS1 @tab 	'\037' 
@item US @tab 	'\037' 
@item space @tab 		' ' 
@item exclamation-mark @tab 	'!' 
@item quotation-mark @tab 	'"' 
@item number-sign @tab 		'#' 
@item dollar-sign @tab 		'$' 
@item percent-sign @tab 		'%' 
@item ampersand @tab 		'&' 
@item apostrophe @tab 		'\'' 
@item left-parenthesis @tab 	'(' 
@item right-parenthesis @tab 	')' 
@item asterisk @tab 	'*' 
@item plus-sign @tab 	'+' 
@item comma @tab 	',' 
@item hyphen @tab 	'-' 
@item hyphen-minus @tab 	'-' 
@item period @tab 	'.' 
@item full-stop @tab 	'.' 
@item slash @tab 	'/' 
@item solidus @tab 	'/' 
@item zero @tab 		'0' 
@item one @tab 		'1' 
@item two @tab 		'2' 
@item three @tab 	'3' 
@item four @tab 		'4' 
@item five @tab 		'5' 
@item six @tab 		'6' 
@item seven @tab 	'7' 
@item eight @tab 	'8' 
@item nine @tab 		'9' 
@item colon @tab 	':' 
@item semicolon @tab 	';' 
@item less-than-sign @tab 	'<' 
@item equals-sign @tab 		'=' 
@item greater-than-sign @tab 	'>' 
@item question-mark @tab 	'?' 
@item commercial-at @tab 	'@' 
@item left-square-bracket @tab 	'[' 
@item backslash @tab 		'\\' 
@item reverse-solidus @tab 	'\\' 
@item right-square-bracket @tab 	']' 
@item circumflex @tab 		'^' 
@item circumflex-accent @tab 	'^' 
@item underscore @tab 		'_' 
@item low-line @tab 		'_' 
@item grave-accent @tab 		'`' 
@item left-brace @tab 		'@{' 
@item left-curly-bracket @tab 	'@{' 
@item vertical-line @tab 	'|' 
@item right-brace @tab 		'@}' 
@item right-curly-bracket @tab 	'@}' 
@item tilde @tab 		'~' 
@item DEL @tab 	'\177' 
@end multitable

@c ****************** Thread ********************
@node Thread Package, C-like Syntax, Regex Package, Top
@chapter Thread
The thread package provides support for multithreaded programming.
This package is based on POSIX thread library.

Before using functions and variables in Thread Package, following
function call should be made to dynamically load necessary library.

@example
(use 'thread)
@end example

@menu
* Basic Thread Operations: Thread-Basic.
* Cancellation: Thread-Cancel.
* Cleanup Handler: Thread-Cleanup.
* Mutex: Thread-Mutex.
* Condition Variable: Thread-Cond.
* Semaphore: Thread-Semaphore.
* Thread-Specific Data: Thread-Data.
* Signal Handling: Thread-Signal
* Miscellaneous Thread Functions: Thread-Misc.
@end menu

@node Thread-Basic, Thread-Cancel, Thread Package, Thread Package
@section Basic Thread Operations
@defun thread:create @var{fun}
@var{fun} (thread function) must be a function that takes no
arguments. @code{thread:create} creates and starts a new thread that
executes @var{fun}. It returns a thread object that represents the new
thread.

It recognizes following keyword arguments.

@multitable @columnfractions 0.2 0.8
@item detachstate
@tab
should be 'joinable or 'detached. Chooses whether the thread is created
in the joinable state or in the detached state.  'joinable is for
@code{PTHREAD_CREATE_JOINABLE}: the thread can be joined later by
@code{thread:join}. 'detached is for @code{PTHREAD_CREATE_DETACHED}: the
thread cannot be joined and resources allocated to the thread is
automatically released when @var{fun} returns. Default is 'joinable.

@item schedpolicy
@tab
should be 'other, 'rr, or 'fifo. Selects the scheduling policy for the
thread. 'other is for @code{SCHED_OTHER}; 'rr is for @code{SCHED_RR};
and 'fifo is for @code{SCHED_FIFO}. Default is 'other.

@item schedparam
@tab
should be an integer. Changes the scheduling priority for the
thread. Default is 0.

@item inheritsched
@tab
should be 'explicit or 'inherit. Chooses whether the scheduling policy
and scheduling parameter for the newly created thread are determined by
the values of @code{schedpolicy} or @code{schedparam}
arguments. 'explicit is for @code{PTHREAD_EXPLICIT_SCHED}: those
attributes are inherited from the parent thread. 'inherit is for
@code{PTHREAD_INHERIT_SCHED}: those attributes determined from
@code{schedpolicy} and @code{schedparam} arguments. Default is
'explicit.

@item scope
@tab
should be 'system or 'process. Chooses the scheduling contention scope
for the created thread. 'system is for @code{PTHREAD_SCOPE_SYSTEM}: the
thread contend for CPU time with all processes running on the
machine. 'process is for @code{PTHREAD_SCOPE_PROCESS}: scheduling
contension occurs only between the threads of the running
process. Default is 'system.
@end multitable

Example:
@example
(thread:create 
  (lambda () 
    (display "Thread 1")
    (newline))
  :detachstate 'detached)  ==> #<thread>
@end example

@use{thread}
@end defun

@defun thread? @var{obj}
Returns @code{#t} if @var{obj} is a thread object, otherwise returns
@code{#f}.
@end defun

@defun thread:exit @var{retval}
Terminates the execution of the calling thread. @var{retval} specifies
the value that can be collected by @code{thread:join}.
@end defun

@defun thread:cancel @var{thread}
Sends a cancellation request to @var{thread}. Returns an unspecified
value.

@use{thread}
@end defun

@defun thread:join @var{thread}
Suspends the execution of the calling thread until @var{thread}
terminates: that is, the thread function returns; @code{thread:exit} is
called; or cancelled by @code{thread:cancel}. When @code{thread}
terminates by cencellation, @code{thread:join} returns an unspecified
value. Otherwise, it returns the value that the thread function returns
or @code{thread:exit} specifies.

@use{thread}
@end defun

@node Thread-Cancel, Thread-Cleanup, Thread-Basic, Thread Package
@section Cancellation
@defun thread:setcancelstate @var{state}
Changes the cancellation state for the calling thread --- that is,
whether cancellation requests are ignored or not. @var{state} should be
either 'enable or 'disable. 'enable is for @code{PTHREAD_CANCEL_ENABLE},
meaning that cancellation is to be enabled. 'disable is for
@code{PTHREAD_CANCEL_DISABLE}, meaning that cancellation is to be
disabled. Returns the current cancellation state ('enable or 'disable).

@example
(thread:setcancelstate 'disable) ==> enable
@end example

@use{thread}
@end defun

@defun thread:setcanceltype @var{type}
Changes the type of responses the type of responses to cancellation
requests. @var{type} should be either 'deferred or
'asynchronous. 'deferred is for @code{PTHREAD_CANCEL_DEFERRED}, to keep
the cancellation request pending until the next cancellation
point. 'asynchronous is for @code{PTHREAD_CANCEL_ASYNCHRONOUS}, to
cancel the thread as soon as the cancellation request is
received. Returns the current cancellation type ('deferred or
'asynchronous).

@use{thread}
@end defun

@defun thread:testcancel
Does nothing except testing for pending cancellation and executing
it. Returns an unspecified value. Its purpose is to introduce explicit
checks for cancellation in long sequences of codes that do not call
cancellation point functions otherwise.

@use{thread}
@end defun

@node Thread-Cleanup, Thread-Mutex, Thread-Cancel, Thread Package
@section Cleanup Handler
@defun thread:with-cleanup @var{cleanup-handler} @var{fun}
Both @var{cleanup-handler} and @var{fun} must be a function that takes
no argument. Calls @var{fun} with no argument. If @var{fun} returns,
@code{thread:with-cleanup} returns that value. In this case,
@var{cleanup-handler} does nothing.  If @var{fun} does not return (that
is, terminated either by @code{thread:exit} or cancellation),
@var{cleanup-handler} is called with no argument on thread termination
and @code{thread:with-cleanup} never returns.

@example
(define mutex (thread:make-mutex))
(begin
  (thread:mutex-lock mutex)
  (thread:with-cleanup
    (lambda () (thread:mutex-unlock mutex))
    (lambda () (some-fun)))
  (thread:mutex-unlock mutex))
@end example

@use{thread}
@end defun

@node Thread-Mutex, Thread-Cond, Thread-Cleanup, Thread Package
@section Mutex
@defun thread:make-mutex
Returns a mutex object.

@use{thread}
@end defun

@defun thread:mutex-lock @var{mutex}
Locks the @var{mutex}. @var{mutex} should be a mutex object.  If the
@var{mutex} is currently unlocked, it becomes locked and owned by the
calling thread, and @code{thread:mutex-lock} returns immediately. If the
mutex is already locked by another thread, @code{thread:mutex-lock}
suspends the calling thread until the mutex is unlocked.  Returns an
unspecified value.

@use{thread}
@end defun

@defun thread:mutex-trylock @var{mutex}
@code{thread:mutex-trylock} tries to lock the @var{mutex}. If the
@var{mutex} is currently unlocked, the @var{mutex} is locked by the
calling thread and @code{thread:mutex-trylock} returns @code{#t}. If the
@var{mutex} is currently locked, it does not block and returns @code{#f}
immediately. 

@use{thread}
@end defun

@defun thread:mutex-unlock @var{mutex}
Unlocks the @var{mutex}. Returns an unspecified value.

@use{thread}
@end defun

@node Thread-Cond, Thread-Semaphore, Thread-Mutex, Thread Package
@section Condition Variable
@defun thread:make-cond
Returns a condition variable object.

@use{thread}
@end defun

@defun thread:cond-signal @var{cond}
Restarts one of the threads that are waiting on the condition variable
@var{cond}. If no threads are waiting on @var{cond}, nothing
happens. Returns an unspecified value.

@use{thread}
@end defun

@defun thread:broadcast @var{cond}
Restarts all the threads that are waiting on the condition variable
@var{cond}. Returns an unspecified value.

@use{thread}
@end defun

@defun thread:cond-wait @var{cond} @var{mutex}
@code{thread:cond-wait} atomically unlocks the @var{mutex} and waits for
the condition variable @var{cond}. The @var{mutex} must be locked by the
calling thread on entrance to @code{thread:cond-wait}. Before returning
to the calling thread, @code{thread:cond-wait} re-acquires
@var{mutex}. Returns an unspecified value.

@use{thread}
@end defun

@defun thread:cond-timedwait @var{cond} @var{mutex} @var{sec}
[@var{nanosec}]

Atomically unlocks @var{mutex} and waits on @var{cond}, as
@var{thread:cond-wait} does, but it also bounds the duration of the
wait. If @var{cond} has not been signaled before the time specified by
@var{sec} and optional @var{nanosec}, @var{mutex} is re-acquired and
@code{thread:cond-timedwait} returns @code{#f}. Otherwise (that is,
@code{cond} is signaled) it returns @code{#t}.

The time specified by @var{sec} and optional @var{nanosec} is an
absolute time. If @var{sec} and @var{nanosec} (if supplied) are both
0, it corresponds to 00:00:00 GMT, January 1, 1970.

@use{thread}
@end defun

@node Thread-Semaphore, Thread-Data, Thread-Cond, Thread Package
@section POSIX Semaphore
@defun thread:make-sem @var{value}
Returns a semaphore object that has an initial value of @var{value}.

@use{thread}
@end defun

@defun thread:sem-wait @var{sem}
Suspends the calling thread until the semaphore represented by @var{sem}
has non-zero value. It then atomically decreases the semaphore value.

@use{thread}
@end defun

@defun thread:sem-trywait @var{sem}
This is a non-blocking variant of @var{thread:sem-wait}. If the
semaphore count is zero, @var{thread:sem-trywaie} does not suspend but
returns @code{#f} immediately. Otherwise the behavior is the same as
@var{thread:wait-sem}. 

@use{thread}
@end defun

@defun thread:sem-post @var{sem}
Atomically increases the value of the semaphore represented by
@var{sem}. Returns an unspecified value.

@use{thread}
@end defun

@defun thread:sem-getvalue @var{sem}
Returns the value of the semaphore represented by @var{sem}.

@use{thread}
@end defun

@node Thread-Data, Thread-Signal, Thread-Semaphore, Thread Package
@section Thread-Specific Data
@defun thread:getspecific @var{key}
@var{key} should be a symbol. Returns the value of thread-specific data
associated with @var{key}.

@use{thread}
@end defun

@defun thread:setspecific @var{key} @var{val}
@var{key} should be a symbol. Associates @var{val} with @var{key} in the
thread-specific data. Returns an unspecified value.

@use{thread}
@end defun

@node Thread-Signal, Thread-Misc, Thread-Data, Thread Package
@section Threads and Signal Handling
@defun thread:sigmask @var{how} @var{newmask}
Changes the signal mask for the calling thread. @var{how} specifies how
the signal mask is changed. If @var{how} is @code{@@SIG_SETMASK}, the
signal mask is set to @var{newmask}. If @var{how} is @code{@@SIG_BLOCK},
the signals specified by @var{newmask} are added to the current signal
mask. If @var{how} is @code{@@SIG_UNBLOCK}, the signals specified by
@var{newmask} are removed from the current signal mask.

@var{newmask} should be a signal set created and manipulated by
signal-related functions @xref{Base-Signal, Signal related functions}.

@example
(define sigset (make-sigset))
(sigemptyset sigset)
(sigaddset sigset @@SIGINT)
(thread:sigmask @@SIG_BLOCK sigset)
@end example

@use{thread}
@end defun

@defun thread:kill @var{thread} @var{signo}
Sends signal number @var{signo} to the thread @var{thread}.

@example
(define th (thread:create 
             (lambda () (let loop () (loop)))))
(thread:kill th @@SIGINT)
@end example

@use{thread}
@end defun

@defun sigwait @var{sigset}
Suspends the calling thread until one of the signals in @var{sigset} is
delivered to the calling thread. Returns the signal number received.

For @code{thread:sigwait} to work reliably, the signals being waited for
must be blocked in all threads, not only in the calling thread. The best
way to achieve this is block those signals before any threads are
created.

@example
(thread:create
  (lambda ()
    (let ((sigset (make-sigset)))
      (sigemptyset sigset)
      (sigaddset sigset @@SIGINT)
      (let loop ()
        (let ((signo (thread:sigwait sigset)))
          (display "SIGINT received")
          (newline)
          (loop))))))
@end example

@use{thread}
@end defun

@node Thread-Misc,  , Thread-Signal, Thread Package
@section Miscellaneous Thread Functions
@defun thread:self
Returns the thread object for the calling thread.

@use{thread}
@end defun

@defun thread:equal? @var{thread1} @var{thread2}
Returns @code{#t} if @var{thread1} and @var{thread2} represent the same
thread, otherwise returns @code{#f}.

@use{thread}
@end defun

@defun thread:detach @var{thread}
Puts the @var{thread} in the detached state. This guarantees that
resources consumed by @var{thread} will be freed immediately when
@var{thread} terminates. However, this prevents other threads from
synchronizing on the termination of @var{thread} using
@code{thread:join}. Returns an unspecified value.

@use{thread}
@end defun

@defun thread:atfork @var{prepare} @var{parent} @var{child}
Registers handler functions to be called just before and just after a
new process is created with @var{fork}. @var{prepare}, @var{parent} ,
and @var{child} should be functions that take no
arguments. @var{prepare} handler will be called from the parent process,
just before the new process is created. @var{parent} handler will be
called from the parent process, just before @code{fork}
returns. @var{child} handler will be called from the child process, just
before @code{fork} returns. @code{thread:atfork} returns an unspecified
value.

@code{thread:atfork} can be called several times to install several sets
of handlers. At @code{fork} time, @var{prepare} handlers are called in
LIFO order (last added, first called), while @var{parent} and
@var{child} handler are called in FIFO order (first added, first
called).

Internally, @code{thread:atfork} uses following global variables:
@@@@atfork_prepare, @@@@atfork_parent, and @@@@atfork_child.

@use{thread}
@end defun

@defun thread:setschedparam @var{thread} @var{policy} @var{priority}
Sets the scheduling parameters for the thread @var{thread}. @var{policy}
can be either @@SCHED_OTHER (regular, non-reltime scheduling),
@@SCHED_RR (realtime, round-robin), or @@SCHED_FIFO (realtime, first-in
first-out). @var{priority} specifies the scheduling priority for the two
realtime policies.

@use{thread}
@end defun

@defun thread:getschedparam @var{thread}
Returns the scheduling policy and scheduling priority for the thread
@var{thread}. Actually, it returns a pair whose @code{car} is an integer
representing the policy (@@SCHED_OTHER, @@SCHED_RR, or @@SCHED_FIFO) and
@code{cdr} is an integer representing the priority.

@example
(thread:getschedparam (thread:self)) ==> (0 . 0)
@end example

@use{thread}
@end defun

@c ***************** C-like Syntax *****************
@node C-like Syntax, Copying, Thread Package, Top
@chapter C-like Syntax

KSM-Scheme accepts C-like syntax to represent Scheme expressions. When
an input begins with @code{(}, it is parsed as a Scheme expression as
usual. Otherwise, it is parsed as a C-like syntax.  A line starting with
@code{;} is regarded as comment in both syntax.

@menu
* Literals: C-like-Literal.
* Declarations: C-like-Declaration.
* Expressions: C-like-Expression.
* Statements: C-like-Statement.
* Function Definitions: C-like-Function.
* Referencing C Variables and Functions: C-like-Ref.
@end menu

@node C-like-Literal, C-like-Declaration, C-like Syntax, C-like Syntax
@section Literals

@subsection Characters

Character constants are written as in the standard Scheme syntax
@xref{Characters}.  This syntax is different from the standard C
syntax. 

@example
#\a          -- 'a'
#\A          -- 'A'
#\(          -- '('
#\Space      -- ' '
#\newline    -- '\n'
#\U@{0@}       -- '\0'
#\U@{D@}       -- '\r'
#\U@{3042@}    -- Unicode 3042(hex)
@end example

@subsection Strings

Strings constants are written as in the Scheme syntax @xref{Strings}.

@example
"Hello, world"
@end example

Following escaping sequences are supported.

@example
"\""      ==> "  (a string composed of a doublequote character)
"\\"      ==> \
"\n"      ==> newline
"\r"      ==> carriage return
"\t"      ==> tab
"\U@{XXXX@} ==> character corresponding to Unicode 
              code value XXXX (hexadecimal)
@end example

When a backslash is followed by a character that is not listed above,
backslash looses its special meaning and represents a backslash
character by itself. This feature is in contrast to the standard C
syntax.

@example
"\b"  ==> a string composed of two characters ('\' and 'b').
@end example

@subsection Numbers

Numerical constants are represented as in the standard C syntax.

@example
12345     -- decimal
01234     -- octal
0x1234aB  -- hexadecimal
1.23      -- floating point
1.23E-3   -- floating point
@end example

Imaginary numbers are represented by appending @code{i} to a real
number.

@example
1i        ( 1i * 1i = -1 )
1.23i     
@end example

@node C-like-Declaration, C-like-Expression, C-like-Literal, C-like Syntax
@section Declarations

All variables must be declared before use, as in C. The syntax of
variable declaration is the same with C except that type specification
part is replaced by the keyword @code{var}.

@example
var lower, upper, step;
var c;
var vec[10];
@end example

The last declaration declares a variable which is a vector with 10
elements.

A variable may be initialized in its declaration, as in C.

@example
var esc = #\\;
var i = 0;
var eps = 1.0e-5;
@end example

If the declaration is in the toplevel (not within @code{@{@}}), the
scope of the variable is the whole program as variables declared by
@code{define} in Scheme. 

If the declaration is within @code{@{@}} block, the scope is within the
block, as automatic variables in C.

@node C-like-Expression, C-like-Statement, C-like-Declaration, C-like Syntax
@section Expressions

All operators except @code{?:} are supported. Operator precedence is as
in the standard C.

@subsection Arithmetic Operators

The binary arithmetic operators are +, -, *, /, and the modulus operator
%. Integer division yields a rational number.

@example
1+2       ==> 3
1+2*3     ==> 7
(1+2)*3   ==> 9
2 / 3     ==> 2/3
@end example

@subsection Relational and Logical Operators

The relational operators are >, >=, <, <=, ==, !=, &&, ||.

@example
1<2       ==> #t
2>=2      ==> #t
2!=2      ==>#f
@end example

@subsection Increment and Decrement Operators

Prefix ++ and -- operators and postfix ++ and -- operators are provided.

@example
var x = 12;
x++         ==> 12, x becomes 13
x = 100;
++x         ==> 101, x becomes 101
@end example

@subsection Bitwise Operators

Bitwise operators are &, |, ^, <<, >>, and ~.

@subsection Assignment Operators and Expressions

Syntax and semantics of assignment expression is the same as in C.

@example
var x;
x = 12       ==> 12
@end example

All the assignment operators (+=, -=, *=, /=, %=, <<=, >>=, &=, ^=, and
|=) are supported.

@subsection Conditional Expressions

The conditional expression, written with the ternary operator @code{?:}
is @emph{not} supported. @code{?} and @code{:} are used for other
purposes in C-like syntax in KSM-Scheme.

@subsection Precedence and Order of Evaluation

Precedence and associativity of all operators are the same with C.

@multitable @columnfractions 0.6 0.4
@item 
OPERATORS 
@tab ASSOCIATIVITY

@item () [] -> .
@tab left to right

@item ! ~ ++ -- + - * & sizeof
@tab right to left

@item * / % 
@tab left to right

@item + - 
@tab left to right

@item << >>
@tab left to right

@item < <= > >=
@tab left to right

@item == !=
@tab left to right

@item &
@tab left to right

@item ^
@tab left to right

@item |
@tab left to right

@item &&
@tab left to right

@item ||
@tab left to right

@item = += -= *= /= %= &= ^= |= <<= >>=
@tab right to left

@item ,
@tab left to right
@end multitable

Unary +, -, and * have higher precedence than the binary forms.

@node C-like-Statement, C-like-Function, C-like-Expression, C-like Syntax
@section Statements

Syntax of statements are the same as in the standard C except that there
are no @code{switch}, @code{continue}, and @code{goto} statements.

In KSM-Scheme, each statement has its value. How this value is
determined is described below.

@subsection Expression Statement

An expression followed by a semicolon is a statement.

@example
x = 0;
i++;
printf("Hello, world!");
@end example

The value of this kind of statement is the value of the expression.

@subsection Block Statement

Braces @code{@{@}} are used to group declarations and statements
together into a compound statement, or block, so that they are
syntactically equivalent to a single statement.

@example
@{
  var x = 1;
  x+2;
@}
@end example

The value of a block statement is the value of the last statement in the
block. Therefore, the value of the above block statement is x+2 (that
is, 3). 

@subsection If-Else Statement

The syntax of if-else statement is the same as C.

Formally, the syntax is 

@example
if ( expression )
  statement1
else
  statement2
@end example

where @code{else} part is optional. 

The value of an if-else statement is the value of statement1 if
expression evaluates to true, or the value of statement2 if expression
evaluates to false. If else part is omitted, and expression evaluates to
false, the value of if-else statement is unspecified.

In KSM-Scheme, a value represents false if it is #f, 0 (integer zero),
0.0 (floating point zero), or NULL (zero pointer). True is represented
by any value that is not false.

@subsection While Statement

The syntax of while statement is

@example
while ( expression )
  statement
@end example

The value of a while statement is unspecified.

Interpretation of true or false in the evaluation of expression is the
same as in if-else statement. 

@code{continue} statement is not supported in KSM-Scheme.

@subsection For Statement

The syntax of for statement is

@example
for ( expr1 ; expr2 ; expr3 )
  statement
@end example

Interpretation of true or false in the evaluation of expr2 is the same
as in if-else statement.

The value of a for statement is unspecified.

@code{continue} statement is not supported in KSM-Scheme.

@subsection Do-While statement

the syntax of do-while statement is

@example
do
  statement
while ( expression );
@end example

Interpretation of true or false in the evaluation of expression is the
same as in if-else statement.

The value of do-while statement is unspecified.

@code{continue} statement is not supported in KSM-Scheme.

@subsection Break statement

The syntax of break statement is

@example
break expression;
@end example

Break statement provides an early exit from @code{for}, @code{while},
and @code{do}.

The value of a break statement is the value of the expression.

@subsection Return Statement

The syntax of return statement is

@example
return expression;
@end example

The value of a break statement is the value of the expression.

@subsection Cond Statement

The syntax of cond statement is

@example
cond @{
  expr1 : stmt
  expr2 : stmt
  ...
  else  : stmt
@}  
@end example

where else clause if optional.

expr1, expr2, ... are evaluated sequentially. When an expression
evaluates true (in the sense described in if-else statement), the
following statement is evaluated and the control exits the cond block.
If else clause is encountered, the following statement is evaluated and
the control exits the cond block.

@example
var x = 1;
cond @{
x%2==0 : 1;
x-1    : 2;
abs(x) : 3;
else   : 4;
@}          ==> 3
@end example

The value of a cond statement is the value of stmt evaluated. If all
expressions evaluates to false, the value of cond statement is
unspecified.

@subsection Case Statement
The syntax of case statement is

@example
case ( expression ) @{
expr [, expr]... : stmt
...
else : stmt
@}
@end example

in which else part is optional. First, expression is evaluated and its
value is compared (in the sense of @code{eqv?}) with the values of expr's
listed on the left side of @code{:}. If one of them is equivalent to the
value of expression, the value of stmt on the right of @code{:} becomes
the value of the case statement. If @code{else} is encountered instead
of expr, the value of the following stmt becomes the value of case
statement unconditionally.

@example
var x = 12;
case(x)@{
1,3,5: #f;
2,4,6: #t;
@}       ==> #t

var y = #\a
case(y)@{
#\a,#\i,#\u,#\e,#\o: 'vowel;
#\w,#\y: 'semiconsonant;
else: ''consonant;
@}       ==> vowel
@end example

@node C-like-Function, C-like-Ref, C-like-Statement, C-like Syntax
@section Function Definition

The syntax of function definition similar to the C syntax except that
type specifications are omitted and that the definition is preceded by
the keyword @code{fun}.

@example
fun @var{identifier} ( @var{para_list} )
  @var{block_stmt}
@end example

The value of function call becomes the value of @var{block_stmt}.

@example
fun add2(x)
@{
  x+2;
@}

add2(3)   ==> 5
var x = 12;
add2(x)   ==> 14

fun sum(x,y)@{ x+y; @}

sum(1,2)  ==> 3
@end example

@code{return} statement is supported.

@example
fun my_sign(x)
@{
  if( x > 0 )
    return 1;
  if( x == 0 ) 0; else -1;
@}

my_sign(0)  ==> 0
@end example

@node C-like-Ref,  , C-like-Function, C-like Syntax
@section Referencing C Variables and Functions

Syntax of referencing C variables and functions becomes very natural
using the C-like syntax. 

By usual C declarations for extern variables and functions (preceded by
the keyword @code{extern}), C variables and functions become accessible
from KSM-Scheme.

@example
extern int errno;

errno    ==> 0

extern int strlen(char *str);

strlen("Hello");    ==> 5
@end example

@c ****************** Copying *********************
@node Copying, GNU General Public License, C-like Syntax, Top
@unnumbered Copying
KSM-Scheme is "free"; this means that everyone is free to use them and
free to reedistribute them on a free basis. KSM-Scheme is not in the
public domain; KSM-Scheme is copyrighted and there are restrictions on
their distribution, but these restrictions are designed to permit
everthing that a good cooperating citizen would want to do. What is not
allowed is to try to prevent others from further sharing any version of
these programs that they might get from you.

Specifically, we want to make sure that you have the right to give away
copies of this program, that you receive source code or else can get it
if you want it, that you can change this program or use pieces of them
in new free programs, and that you know you can do these things.

To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights. For example, if you distribute
copies of KSM-Scheme, you must give the recipients all the rights that
you have. You must make sure that they, too, receive or can get the
source code. And you must tell them their rights.

Also, for our own protections, we must make certain that everyone finds
out that there is no warranty for KSM-Scheme. If this program is
modified by someone else and passed on, we want their recipients to know
that what they have is not what we distributed, so that any problems
introduced by others will not reflect on our reputation.

The preciese conditions of the licenses for KSM-Scheme currently being
distributed are found in the General Public Licenses that accompany it.

@c ****************** GPL **********************
@node GNU General Public License, Concept Index, Copying, Top
@unnumbered GNU General Public License
		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

The Free Software Foundation has exempted Bash from the requirement of
Paragraph 2c of the General Public License.  This is to say, there is
no requirement for Bash to print a notice when it is started
interactively in the usual way.  We made this exception because users
and standards expect shells not to print such messages.  This
exception applies to any program that serves as a shell and that is
based primarily on Bash as opposed to other GNU software.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	Appendix: How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) 19yy  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) 19yy name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.

@c ****************** Concept Index *****************
@node Concept Index, Function Index, GNU General Public License, Top
@unnumbered Concept Index
@printindex cp

@c ****************** Function Index ****************
@node Function Index,  , Concept Index, Top
@unnumbered Function Index
@printindex fn

@contents

@bye


